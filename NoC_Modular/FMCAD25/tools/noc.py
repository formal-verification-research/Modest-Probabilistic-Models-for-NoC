import math
import enum
from typing import Callable
from pathlib import Path

class PropertyType(enum.Enum):
    RESISTIVE = 1
    INDUCTIVE = 2
    BOTH_RI = 3
    FUNCTION = 4
    NO_PROPS = 5

def add_info(func: Callable[..., str]) -> Callable[..., str]:
    """
    A decorator that appends a newline character to the end of a string returned by a function.

    Args:
        func: The function to be decorated.

    Returns:
        The decorated function.
    """
    def wrapper(*args, **kwargs) -> str:
        result: str = func(*args, **kwargs)

        func_name: str = func.__name__
        filename: str = Path(__file__).name

        info_start: str = f"// [info][section start] Section automatically generated by `{func_name}()` in '{filename}'\n"
        info_end: str   = f"// [info][section end] Section automatically generated by `{func_name}()`\n"

        return info_start + result + info_end + "\n"
    return wrapper


class Noc:
    def __init__(self, size: int, *, 
                 buffer_size: int = 4,
                 activity_thresh: int = 3,
                 injection_rate_numerator: int = 3,
                 injection_rate_denominator: int = 10,
                 resistive_noise_threshold: int = 1,
                 inductive_noise_threshold: int = 1):
        assert size >= 2, "Size must be at least 2x2"

        self.num_nodes = size * size
        self.dimension = size
        self.buffer_size = buffer_size
        self.activity_thresh = activity_thresh
        self.injection_rate_numerator = injection_rate_numerator
        self.injection_rate_denominator = injection_rate_denominator
        self.resistive_noise_threshold = resistive_noise_threshold
        self.inductive_noise_threshold = inductive_noise_threshold
    
    def print(self, ptype: PropertyType, *, clk_low: int = 0, clk_high: int = 100, stride: int = 1):
        return self.type() \
                + self.user_defined_constants() \
                + self.calculated_constants()\
                + self.functional_datatypes(ptype) \
                + self.verification_datatypes() \
                + self.variables(ptype) \
                + self.functions() \
                + self.processes(ptype) \
                + self.composition() \
                + self.properties(ptype, clk_low=clk_low, clk_high=clk_high, stride=stride)

    @add_info
    def type(self) -> str:
        return "option \"dtmc\";\n"

    @add_info
    def user_defined_constants(self) -> str:
        return f"""\
//----- User Defined Constants -----

// #CUSTOMIZE
// Set the dimensions for the NoC, note that square dimensions are currently
// the only accepted dimensions
const int NOC_MESH_WIDTH = {self.dimension};
const int NOC_MESH_HEIGHT = {self.dimension};

// #CUSTOMIZE 
// This value changes the buffer length of all buffers.
const int BUFFER_LENGTH = {self.buffer_size};

// #CUSTOMIZE 
// These values change the frequency with witch flits are injected.
const int INJECTION_RATE_NUMERATOR = {self.injection_rate_numerator};
const int INJECTION_RATE_DENOMINATOR = {self.injection_rate_denominator};

// #CUSTOMIZE
// This represents a cyclic clock counter that wraps from 0 to INJECTION_RATE_DENOMINATOR - 1
// and it's used to determine the flit generation pattern. For unique patterns you'll need
// to adjust this to meet your use case.
int(0..INJECTION_RATE_DENOMINATOR) clk = 0;
transient int(0..1) clk_indicator;

// #CUSTOMIZE the number of buffers a router must service before noise will be incremented.
const int ACTIVITY_THRESH = {self.activity_thresh};

// #CUSTOMIZE this is the upper threshoold for noise detected in the system.
const int RESISTIVE_NOISE_THRESH = {self.resistive_noise_threshold};
const int INDUCTIVE_NOISE_THRESH = {self.inductive_noise_threshold};
"""

    @add_info
    def calculated_constants(self) -> str:
        return """\
// ----- Calculated Constants -----

// The max id for each router in the NoC. Ids range from 0 to NOC_MAX_ID in a
// left-to-right, line by line pattern in the NoC
/*
e.g. a 2x2 NoC with it's corresponding ids

 0 -- 1
 |    |
 2 -- 3
*/
const int NOC_MAX_ID = (NOC_MESH_WIDTH * NOC_MESH_HEIGHT) - 1;

// Enumerated values representing the different directions in the
// mesh
const int NORTH = 0;
const int WEST = 1;
const int EAST = 2;
const int SOUTH = 3;
const int LOCAL = 4;
const int NO_CONNECT = -1;
"""
    
    @add_info
    def functional_datatypes(self, ptype: PropertyType) -> str:
        first_half: str = """\
// ----- Functional Datatypes -----

datatype buffer = {
    int(0..NOC_MAX_ID) hd,
    buffer option tl
};

datatype channel = {
    buffer option buffer,
    bool serviced,
    bool isEmpty,
    bool isFull
};

datatype router = {
    channel[] channels,
    int(-1..NOC_MAX_ID)[] ids,
    int(0..4)[] priority_list,
    int(0..4)[] priority_list_temp,
    int(0..4) serviced_index,
    int(0..4) unserviced_index,
    int(0..5) total_unserviced,
"""

        optional_vars: str = """\
	int thisActivity,
	int lastActivity,
"""

        second_half: str = """\
    bool[] used
};
"""

        return first_half + second_half \
                if ptype == PropertyType.FUNCTION \
                else first_half + optional_vars + second_half 

    @add_info
    def verification_datatypes(self) -> str:
        return """\
// ----- Verification Datatypes -----

datatype sendCounter = {
    int(0..2)[] counts
};
"""

    @add_info
    def noc_init(self, ptype: PropertyType) -> str:
        init: str = "router[] noc = [\n"

        for y in range(self.dimension):
            for x in range(self.dimension):
                # calculate the linearized id
                id = x + y * self.dimension

                # calculate the id's of surrounding routers
                id_north = x + (y - 1) * self.dimension
                id_west = (x - 1) + y * self.dimension
                id_east = (x + 1) + y * self.dimension
                id_south = x + (y + 1) * self.dimension

                if y - 1 < 0:
                    id_north = "NO_CONNECT"
                if x - 1 < 0:
                    id_west = "NO_CONNECT"
                if x + 1 >= self.dimension:
                    id_east = "NO_CONNECT"
                if y + 1 >= self.dimension:
                    id_south = "NO_CONNECT"

                init += f"""\
router {{
    channels: [
        channel {{buffer: none, serviced: false, isEmpty: true, isFull: false}},
        channel {{buffer: none, serviced: false, isEmpty: true, isFull: false}},
        channel {{buffer: none, serviced: false, isEmpty: true, isFull: false}},
        channel {{buffer: none, serviced: false, isEmpty: true, isFull: false}},
        channel {{buffer: none, serviced: false, isEmpty: true, isFull: false}}],
    ids: [{id_north}, {id_west}, {id_east}, {id_south}],
    priority_list: [NORTH, EAST, SOUTH, WEST, LOCAL],
    priority_list_temp: [0, 0, 0, 0, 0],
    serviced_index: 0,
    unserviced_index: 0,
    total_unserviced: 0,
"""
                
                if ptype != PropertyType.FUNCTION:
                    init += """\
    thisActivity: 0,
    lastActivity: 0,
"""
                init += """\
    used: [false, false, false, false, false]
}"""
                if id < self.num_nodes - 1:
                    init += ",\n"
                else:
                    init += "];\n"
                
        return init
    
    @add_info
    def verification_init(self) -> str:
        init: str = "sendCounter[] sendCounts = [\n"

        for i in range(self.num_nodes):
            init += "    sendCounter{counts:[0, 0, 0, 0, 0, 0]}"
            if i < self.num_nodes - 1:
                init += ","
            init += "\n"
        
        init += "];\n"

        return init
    
    @add_info
    def noise_tracking_init(self) -> str:
        return """\
int resistiveNoise = 0;
int inductiveNoise = 0;
"""

    @add_info
    def variables(self, ptype: PropertyType) -> str:
        var = "// ----- Variables -----\n\n"
        var += self.noc_init(ptype)

        if ptype == PropertyType.FUNCTION:
            var += self.verification_init()
        else:
            var += self.noise_tracking_init()
        
        return var

    @add_info
    def functions(self) -> str:
        return """\
// ----- Integer functions -----

// Saturating addition
function int sat_add(int l, int r, int max) =
    if (l + r) > max then max
    else l + r;

// ----- Boolean Algebra Functions -----

// Boolean implication (l ==> r)
function bool implies(bool l, bool r) = (!l) || r;

// ----- List Functions -----

// Calculate length of list
function int len(buffer option ls) = if ls == none then 0 else 1 + len(ls!.tl);

// Add a flit to the buffer
function buffer option enqueue(int n, buffer option ls) =
    some(buffer {
        hd: n,
        tl: ls
    });

// Remove a flit from the buffer
function buffer option dequeue(buffer option ls) =
    if ls == none then none
    else if ls!.tl == none then none
    else some(buffer {
        hd: ls!.hd,
        tl: dequeue(ls!.tl)
    });

// Returns true if the buffer `ls` contains `id`, otherwise returns false 
function bool contains(int id, buffer option ls) =
	if ls == none then false
    else if ls!.hd == id then true
	else contains(id, ls!.tl);

// Return the front of the queue
function int peekFront(buffer option ls) =
    if ls == none then -1
    else if ls!.tl == none then ls!.hd
    else peekFront(ls!.tl);

// ----- Buffer Specific Functions -----

// Tell if the buffer is full
function bool isBufferFull(buffer option ls) = len(ls) >= BUFFER_LENGTH;

// ----- Routing Functions

// Get the mirror direction to determine what buffer will receive the flit
// e.g. if we are R0 and we are sending across the South Channel to R2,
// then R2 should receive the flit in their North Buffer
function int getDestinationChannel(int dir) =
    if dir == NORTH then SOUTH
    else if dir == WEST then EAST
    else if dir == EAST then WEST
    else if dir == SOUTH then NORTH
    else -1;

// Calculate what column a specific ID is destined for
function int idToColumn(int id) = (id % NOC_MESH_WIDTH);

// Calculate what row a specific ID is destined for
function int idToRow(int id) = (int)(id / NOC_MESH_HEIGHT);

// Determine if the flits destination is in the same column as the current router
// Returns < 0 if id needs to go to the left, > 0 to go right, and 0 if it's the
// correct column
function int getColumnShift(int id, int dst) = idToColumn(dst) - idToColumn(id);
"""
    
    @add_info
    def processes(self, ptype: PropertyType, generate_flits: str | None) -> str:
        if generate_flits is None:
            generate_flits = """\
process GenerateFlits(int id) {
    int(0..NOC_MAX_ID) destination;

    if (!isBufferFull(noc[id].channels[LOCAL].buffer) && clk < INJECTION_RATE_NUMERATOR) {
        // Add the new flit to the local buffer
        // If the destination is greater than or equal to the ID, we shift it
        // up by one to exclude the possiblity of sending a flit to ourselves
        generateFlits {=
            0: destination = DiscreteUniform(0, NOC_MAX_ID - 1),
            1: noc[id].channels[LOCAL].buffer = 
                enqueue(destination >= id ? 
                            destination + 1 : 
                            destination, noc[id].channels[LOCAL].buffer)
        =}
    }
    else {
        generateFlits // Take this action instead of tau for better synchronization
    }
}"""

        verification: str = """\
// ----- Processes -----
// General guidance for processes is that we want as much synchronized assignments to happen
// as possible. A digital system is by default a synchronous system, so we don't typically
// need worry about interleavings for our design. To accomplish this most processes also 
// have an associated action with the same name that synchronizes assignments between
// routers within those processes.

// #CUSTOMIZE
// This method is how flits are generated for the NoC. To change the flit injection pattern
// change this method.
// Flits are injected into a router's LOCAL buffer and then the router automatically routes
// the flits to their destination.
action generateFlits;
""" + \
generate_flits + \
"""\

// Set the `isEmpty` and `isFull` flags for each channel based off the current
// state of the buffers in the channel
action prepRouter;
process PrepRouter(int id) {
    // Prep all the channels
    prepRouter {=
        // North Channel (0)
        noc[id].channels[NORTH].isEmpty = len(noc[id].channels[NORTH].buffer) == 0,
        noc[id].channels[NORTH].isFull = isBufferFull(noc[id].channels[NORTH].buffer),

        // WEST Channel (1)
        noc[id].channels[WEST].isEmpty = len(noc[id].channels[WEST].buffer) == 0,
        noc[id].channels[WEST].isFull = isBufferFull(noc[id].channels[WEST].buffer),

        // East Channel (2)
        noc[id].channels[EAST].isEmpty = len(noc[id].channels[EAST].buffer) == 0,
        noc[id].channels[EAST].isFull = isBufferFull(noc[id].channels[EAST].buffer),

        // South Channel (3)
        noc[id].channels[SOUTH].isEmpty = len(noc[id].channels[SOUTH].buffer) == 0,
        noc[id].channels[SOUTH].isFull = isBufferFull(noc[id].channels[SOUTH].buffer),

        // Local Channel (4)
        noc[id].channels[LOCAL].isEmpty = len(noc[id].channels[LOCAL].buffer) == 0,
        noc[id].channels[LOCAL].isFull = isBufferFull(noc[id].channels[LOCAL].buffer),

        // #VERIFICATION
        // Reset send counts
        sendCounts[id].counts[NORTH] = 0,
        sendCounts[id].counts[WEST] = 0,
        sendCounts[id].counts[EAST] = 0,
        sendCounts[id].counts[SOUTH] = 0,
        sendCounts[id].counts[LOCAL] = 0
    =}
}

// Send a flit from Router `id` across channel `ch` in the specified direction `dir`
process Send(int id, int ch, int dir) {
    advanceChannel;

    // If the destination is not full, and the channel has not been used in this cycle, then service the buffer
    if(!noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].isFull && !noc[id].used[dir]){
        advanceChannelSend {=
            // #VERIFICATION
            // Increment the send counts using a saturating count
            0: sendCounts[id].counts[ch] = sat_add(sendCounts[id].counts[ch], 1, 2),

            // Add flit to destination buffer
            1: noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].buffer =
                enqueue(peekFront(noc[id].channels[ch].buffer), noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].buffer),

            // Then, remove it from the source buffer
            2: noc[id].channels[ch].buffer = dequeue(noc[id].channels[ch].buffer),

            // Mark that output as used and that channel as serviced
            4: noc[id].used[dir] = true,
            4: noc[id].channels[ch].serviced = true
        =}
    }
    // Otherwise, increment total unserviced buffers
    else{
        advanceChannelSend {=
            noc[id].total_unserviced++
        =}
    }
}

// Determine which direction to send the front-most flit in channel `ch` of router `id`
process AdvanceFlits(int id, int ch) {
    // If flit needs to stay on this row
    if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) == 0) {
        // Send it north
        if(peekFront(noc[id].channels[ch].buffer) < id){
            Send(id, ch, NORTH)
        }
        // Or send it south
        else{
            Send(id, ch, SOUTH)
        }
    }
    // Else, if flit needs to go west
    else if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) < 0) {
        Send(id, ch, WEST)
    }
    // Else, flit needs to go east
    else{
        Send(id, ch, EAST)
    }
}

// Advance a specific channel `ch` in router `id`
action advanceChannel;
action advanceChannelSend;
process AdvanceChannel(int id, int ch) {
    // If this channel was not assigned a neighbor or if it is
    // empty, then mark it as serviced and move on to the next one
    if ((ch != 4 && noc[id].ids[ch] == NO_CONNECT) || noc[id].channels[ch].isEmpty == true) {
        advanceChannel {=
            // Mark the channel as serviced
            noc[id].channels[ch].serviced = true
        =};
	    advanceChannelSend
    }
    // If the flit has reached its destination...
    else if (peekFront(noc[id].channels[ch].buffer) == id) {
        advanceChannel {=
            /* -- if the local channel has not been used this clock cycle -- */
            // Mark the channel as serviced and used
            noc[id].channels[ch].serviced = !noc[id].used[LOCAL],
            noc[id].used[LOCAL] = !noc[id].used[LOCAL],

            // Remove this flit. It has reached its destination
            noc[id].channels[ch].buffer = !noc[id].used[LOCAL] ? dequeue(noc[id].channels[ch].buffer) : noc[id].channels[ch].buffer,

            /* -- if the local channel has been used this clock cycle -- */
            // Otherwise, increment total unserviced buffers
            noc[id].total_unserviced = !noc[id].used[LOCAL] ? noc[id].total_unserviced : noc[id].total_unserviced + 1
        =};
	    advanceChannelSend
    }
    // Otherwise, the flit must be for another router
    else {
        AdvanceFlits(id, ch)
    }
}

// Advance every channel in the router in the order of the priority list
process AdvanceRouter(int id) {
    AdvanceChannel(id, noc[id].priority_list[0]);
    AdvanceChannel(id, noc[id].priority_list[1]);
    AdvanceChannel(id, noc[id].priority_list[2]);
    AdvanceChannel(id, noc[id].priority_list[3]);
    AdvanceChannel(id, noc[id].priority_list[4])
}

// Update the priority list value at index `i` in router `id`
process UpdatePriorityList(int id, int i) {
    if (noc[id].channels[noc[id].priority_list[i]].serviced) {
        updatePriority {=
            0: noc[id].priority_list_temp[noc[id].total_unserviced + noc[id].serviced_index] = noc[id].priority_list[i],
            1: noc[id].serviced_index++
        =}
    }
    else {
        updatePriority {=
            0: noc[id].priority_list_temp[noc[id].unserviced_index] = noc[id].priority_list[i],
            1: noc[id].unserviced_index++
        =}
    }
}

// Update the entire priority list (schedule) for router `id`
action updatePriority;
process UpdatePiority(int id) {
    // Reset all of the temp values
    updatePriority {=
        noc[id].priority_list_temp = [0, 0, 0, 0, 0],
        noc[id].serviced_index = 0,
        noc[id].unserviced_index = 0
    =};

    // Update the ordering of priorities in the lists
    UpdatePriorityList(id, 0);
    UpdatePriorityList(id, 1);
    UpdatePriorityList(id, 2);
    UpdatePriorityList(id, 3);
    UpdatePriorityList(id, 4);

    updatePriority {=
        // Make our next priority list the current priority list
        // However, if all of our channels are empty, then just reset
        // the priority list. This helps with the state space
        0: noc[id].priority_list = (noc[id].channels[0].isEmpty &&
                                    noc[id].channels[1].isEmpty &&
                                    noc[id].channels[2].isEmpty &&
                                    noc[id].channels[3].isEmpty &&
                                    noc[id].channels[4].isEmpty) ?
                                    [NORTH, EAST, SOUTH, WEST, LOCAL] : noc[id].priority_list_temp,

        // Reset the used and serviced variables
        1: noc[id].channels[0].serviced = false,
        1: noc[id].channels[1].serviced = false,
        1: noc[id].channels[2].serviced = false,
        1: noc[id].channels[3].serviced = false,
        1: noc[id].channels[4].serviced = false,
        1: noc[id].total_unserviced = 0,
        1: noc[id].used = [false, false, false, false, false],
        1: noc[id].priority_list_temp = [0, 0, 0, 0, 0],
        1: noc[id].serviced_index = 0,
        1: noc[id].unserviced_index = 0
    =}
}

// Router model
process Router(int id) {
    // Generate new flits
    GenerateFlits(id);

    // Determine what channels will send this cycle
    PrepRouter(id);

    // Send the flits
    AdvanceRouter(id);

    // Update the priority list
    UpdatePiority(id);

    // Sync w/ the clock -
    nextClockCycle;

    // recursive call for next clock cycle
    Router(id)
}

// Model the cyclic clock
action nextClockCycle;
process Clock() {
    nextClockCycle {= clk = (clk + 1) % INJECTION_RATE_DENOMINATOR, clk_indicator = 1 =};
    Clock()
}
"""

        functional: str = """\
// ----- Processes -----
// General guidance for processes is that we want as much synchronized assignments to happen
// as possible. A digital system is by default a synchronous system, so we don't typically
// need worry about interleavings for our design. To accomplish this most processes also 
// have an associated action with the same name that synchronizes assignments between
// routers within those processes.

// #CUSTOMIZE
// This method is how flits are generated for the NoC. To change the flit injection pattern
// change this method.
// Flits are injected into a router's LOCAL buffer and then the router automatically routes
// the flits to their destination.
action generateFlits;
""" + \
generate_flits + \
"""\

// Set the `isEmpty` and `isFull` flags for each channel based off the current
// state of the buffers in the channel
action prepRouter;
process PrepRouter(int id) {
    // Prep all the channels
    prepRouter {=
        // North Channel (0)
        noc[id].channels[NORTH].isEmpty = len(noc[id].channels[NORTH].buffer) == 0,
        noc[id].channels[NORTH].isFull = isBufferFull(noc[id].channels[NORTH].buffer),

        // WEST Channel (1)
        noc[id].channels[WEST].isEmpty = len(noc[id].channels[WEST].buffer) == 0,
        noc[id].channels[WEST].isFull = isBufferFull(noc[id].channels[WEST].buffer),

        // East Channel (2)
        noc[id].channels[EAST].isEmpty = len(noc[id].channels[EAST].buffer) == 0,
        noc[id].channels[EAST].isFull = isBufferFull(noc[id].channels[EAST].buffer),

        // South Channel (3)
        noc[id].channels[SOUTH].isEmpty = len(noc[id].channels[SOUTH].buffer) == 0,
        noc[id].channels[SOUTH].isFull = isBufferFull(noc[id].channels[SOUTH].buffer),

        // Local Channel (4)
        noc[id].channels[LOCAL].isEmpty = len(noc[id].channels[LOCAL].buffer) == 0,
        noc[id].channels[LOCAL].isFull = isBufferFull(noc[id].channels[LOCAL].buffer)
    =}
}

// Send a flit from Router `id` across channel `ch` in the specified direction `dir`
process Send(int id, int ch, int dir) {
    advanceChannel;

    // If the destination is not full, and the channel has not been used in this cycle, then service the buffer
    if(!noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].isFull && !noc[id].used[dir]){
        advanceChannelSend {=
            // Add flit to destination buffer
            1: noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].buffer =
                enqueue(peekFront(noc[id].channels[ch].buffer), noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].buffer),

            // Then, remove it from the source buffer
            2: noc[id].channels[ch].buffer = dequeue(noc[id].channels[ch].buffer),

            // Mark that output as used and that channel as serviced
            4: noc[id].used[dir] = true,
            4: noc[id].channels[ch].serviced = true,

			// Increment the count for buffers serviced in this cycle
			4: noc[id].thisActivity++
        =}
    }
    // Otherwise, increment total unserviced buffers
    else{
        advanceChannelSend {=
            noc[id].total_unserviced++
        =}
    }
}

// Determine which direction to send the front-most flit in channel `ch` of router `id`
process AdvanceFlits(int id, int ch) {
    // If flit needs to stay on this row
    if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) == 0) {
        // Send it north
        if(peekFront(noc[id].channels[ch].buffer) < id){
            Send(id, ch, NORTH)
        }
        // Or send it south
        else{
            Send(id, ch, SOUTH)
        }
    }
    // Else, if flit needs to go west
    else if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) < 0) {
        Send(id, ch, WEST)
    }
    // Else, flit needs to go east
    else{
        Send(id, ch, EAST)
    }
}

// Advance a specific channel `ch` in router `id`
action advanceChannel;
action advanceChannelSend;
process AdvanceChannel(int id, int ch) {
    // If this channel was not assigned a neighbor or if it is
    // empty, then mark it as serviced and move on to the next one
    if ((ch != 4 && noc[id].ids[ch] == NO_CONNECT) || noc[id].channels[ch].isEmpty == true) {
        advanceChannel {=
            // Mark the channel as serviced
            noc[id].channels[ch].serviced = true
        =};
	    advanceChannelSend
    }
    // If the flit has reached its destination...
    else if (peekFront(noc[id].channels[ch].buffer) == id) {
        advanceChannel {=
            /* -- if the local channel has not been used this clock cycle -- */
            // Mark the channel as serviced and used
            noc[id].channels[ch].serviced = !noc[id].used[LOCAL],
            noc[id].used[LOCAL] = !noc[id].used[LOCAL],

            // Remove this flit. It has reached its destination
            noc[id].channels[ch].buffer = !noc[id].used[LOCAL] ? dequeue(noc[id].channels[ch].buffer) : noc[id].channels[ch].buffer,

            // Increment the activity for this cycle as we removed a flit
            noc[id].thisActivity = !noc[id].used[LOCAL] ? noc[id].thisActivity + 1 : noc[id].thisActivity,

            /* -- if the local channel has been used this clock cycle -- */
            // Otherwise, increment total unserviced buffers
            noc[id].total_unserviced = !noc[id].used[LOCAL] ? noc[id].total_unserviced : noc[id].total_unserviced + 1
        =};
	    advanceChannelSend
    }
    // Otherwise, the flit must be for another router
    else {
        AdvanceFlits(id, ch)
    }
}

// Advance every channel in the router in the order of the priority list
process AdvanceRouter(int id) {
    AdvanceChannel(id, noc[id].priority_list[0]);
    AdvanceChannel(id, noc[id].priority_list[1]);
    AdvanceChannel(id, noc[id].priority_list[2]);
    AdvanceChannel(id, noc[id].priority_list[3]);
    AdvanceChannel(id, noc[id].priority_list[4])
}

// Update the priority list value at index `i` in router `id`
process UpdatePriorityList(int id, int i) {
    if (noc[id].channels[noc[id].priority_list[i]].serviced) {
        updatePriority {=
            0: noc[id].priority_list_temp[noc[id].total_unserviced + noc[id].serviced_index] = noc[id].priority_list[i],
            1: noc[id].serviced_index++
        =}
    }
    else {
        updatePriority {=
            0: noc[id].priority_list_temp[noc[id].unserviced_index] = noc[id].priority_list[i],
            1: noc[id].unserviced_index++
        =}
    }
}

// Update the entire priority list (schedule) for router `id`
action updatePriority;
process UpdatePiority(int id) {
    // Reset all of the temp values
    updatePriority {=
        noc[id].priority_list_temp = [0, 0, 0, 0, 0],
        noc[id].serviced_index = 0,
        noc[id].unserviced_index = 0
    =};

    // Update the ordering of priorities in the lists
    UpdatePriorityList(id, 0);
    UpdatePriorityList(id, 1);
    UpdatePriorityList(id, 2);
    UpdatePriorityList(id, 3);
    UpdatePriorityList(id, 4);

    updatePriority {=
        // Make our next priority list the current priority list
        // However, if all of our channels are empty, then just reset
        // the priority list. This helps with the state space
        0: noc[id].priority_list = (noc[id].channels[0].isEmpty &&
                                    noc[id].channels[1].isEmpty &&
                                    noc[id].channels[2].isEmpty &&
                                    noc[id].channels[3].isEmpty &&
                                    noc[id].channels[4].isEmpty) ?
                                    [NORTH, EAST, SOUTH, WEST, LOCAL] : noc[id].priority_list_temp,

        // Reset the used and serviced variables
        1: noc[id].channels[0].serviced = false,
        1: noc[id].channels[1].serviced = false,
        1: noc[id].channels[2].serviced = false,
        1: noc[id].channels[3].serviced = false,
        1: noc[id].channels[4].serviced = false,
        1: noc[id].total_unserviced = 0,
        1: noc[id].used = [false, false, false, false, false],
        1: noc[id].priority_list_temp = [0, 0, 0, 0, 0],
        1: noc[id].serviced_index = 0,
        1: noc[id].unserviced_index = 0
    =}
}

process UpdateGlobalNoiseTracking(int id) {
    {= 
       // Update inductive noise
       0: inductiveNoise += abs(noc[id].lastActivity - noc[id].thisActivity) >= ACTIVITY_THRESH ? 1 : 0,

       // Update resistive noise
       0: resistiveNoise += noc[id].thisActivity >= ACTIVITY_THRESH ? 1 : 0,

       // Update trackers for next round
       1: noc[id].lastActivity = noc[id].thisActivity,
       2: noc[id].thisActivity = 0
    =}
}

// Router model
process Router(int id) {
    // Generate new flits
    GenerateFlits(id);

    // Determine what channels will send this cycle
    PrepRouter(id);

    // Send the flits
    AdvanceRouter(id);

    // Update the priority list
    UpdatePiority(id);

    // Update noise tracking
    UpdateGlobalNoiseTracking(id);

    // Sync w/ the clock -
    nextClockCycle;

    // recursive call for next clock cycle
    Router(id)
}

// Model the cyclic clock
action nextClockCycle;
process Clock() {
    nextClockCycle {= clk = (clk + 1) % INJECTION_RATE_DENOMINATOR, clk_indicator = 1 =};
    Clock()
}
"""

        if ptype == PropertyType.FUNCTION:
            return verification
        else:
            return functional

    @add_info
    def composition(self) -> str:
        composition: str = "par {\n    :: Clock()\n"
        for i in range(self.num_nodes):
            composition += f"    :: Router({i})\n"
        composition += "}\n"

        return composition

    def resistive_noise(self, clk: int) -> str:
        return f"""\
property resistiveNoiseProbability1RewardBounded{clk}  = Pmax(<>[S(clk_indicator)<={clk}] (resistiveNoise >= RESISTIVE_NOISE_THRESH));
"""
    
    def inductive_noise(self, clk: int) -> str:
        return f"""\
property inductiveNoiseProbability1RewardBounded{clk}  = Pmax(<>[S(clk_indicator)<={clk}]  (inductiveNoise >= INDUCTIVE_NOISE_THRESH));
"""

    def resistive_range(self, clk_low: int, clk_high: int, stride: int = 1) -> str:
        properties: str = ""
        for clk in range(clk_low, clk_high+1, stride):
            properties += self.resistive_noise(clk)
        return properties
    
    def inductive_range(self, clk_low: int, clk_high: int, stride: int = 1) -> str:
        properties: str = ""
        for clk in range(clk_low, clk_high+1, stride):
            properties += self.inductive_noise(clk)
        return properties
    
    def correctness(self) -> str:
        prop: str = ""

        # never generates flits for self (flit generation correctness)
        prop += "// Flit generation verification\n"
        for i in range(self.num_nodes):
            prop += f"property neverGeneratesFlitsForSelf{i} = A[](!(contains({i}, noc[{i}].channels[LOCAL].buffer)));\n"
        prop += "\n"

        # priority list is always valid
        prop += "// Valid priority list\n"
        for i in range(self.num_nodes):
            prop += f"""\
property alwaysContainsNorth{i} = A[](noc[{i}].priority_list[0] == NORTH || noc[{i}].priority_list[1] == NORTH || noc[{i}].priority_list[2] == NORTH || noc[{i}].priority_list[3] == NORTH || noc[{i}].priority_list[4] == NORTH);
property alwaysContainsEast{i}  = A[](noc[{i}].priority_list[0] == EAST  || noc[{i}].priority_list[1] == EAST  || noc[{i}].priority_list[2] == EAST  || noc[{i}].priority_list[3] == EAST  || noc[{i}].priority_list[4] == EAST);
property alwaysContainsSouth{i} = A[](noc[{i}].priority_list[0] == SOUTH || noc[{i}].priority_list[1] == SOUTH || noc[{i}].priority_list[2] == SOUTH || noc[{i}].priority_list[3] == SOUTH || noc[{i}].priority_list[4] == SOUTH);
property alwaysContainsWest{i}  = A[](noc[{i}].priority_list[0] == WEST  || noc[{i}].priority_list[1] == WEST  || noc[{i}].priority_list[2] == WEST  || noc[{i}].priority_list[3] == WEST  || noc[{i}].priority_list[4] == WEST);
property alwaysContainsLocal{i} = A[](noc[{i}].priority_list[0] == LOCAL || noc[{i}].priority_list[1] == LOCAL || noc[{i}].priority_list[2] == LOCAL || noc[{i}].priority_list[3] == LOCAL || noc[{i}].priority_list[4] == LOCAL);

property allPrioritiesAreUnique{i}  = A[]((noc[{i}].priority_list[0] != noc[{i}].priority_list[1]) &&
                                          (noc[{i}].priority_list[0] != noc[{i}].priority_list[2]) && 
                                          (noc[{i}].priority_list[0] != noc[{i}].priority_list[3]) && 
                                          (noc[{i}].priority_list[0] != noc[{i}].priority_list[4]) && 
                                          (noc[{i}].priority_list[1] != noc[{i}].priority_list[2]) && 
                                          (noc[{i}].priority_list[1] != noc[{i}].priority_list[3]) && 
                                          (noc[{i}].priority_list[1] != noc[{i}].priority_list[4]) && 
                                          (noc[{i}].priority_list[2] != noc[{i}].priority_list[3]) && 
                                          (noc[{i}].priority_list[2] != noc[{i}].priority_list[4]) && 
                                          (noc[{i}].priority_list[3] != noc[{i}].priority_list[4]));

"""
        prop += "\n"

        # buffer length valid
        prop += "// Buffer length validation (never goes past specified size)\n"
        for i in range(self.num_nodes):
            prop += f"""\
property r{i}BufferSizeAlwaysValidNorth = A[](len(noc[{i}].channels[NORTH].buffer) <= BUFFER_LENGTH);
property r{i}BufferSizeAlwaysValidEast  = A[](len(noc[{i}].channels[EAST].buffer)  <= BUFFER_LENGTH);
property r{i}BufferSizeAlwaysValidSouth = A[](len(noc[{i}].channels[SOUTH].buffer) <= BUFFER_LENGTH);
property r{i}BufferSizeAlwaysValidWest  = A[](len(noc[{i}].channels[WEST].buffer)  <= BUFFER_LENGTH);
property r{i}BufferSizeAlwaysValidLocal = A[](len(noc[{i}].channels[LOCAL].buffer) <= BUFFER_LENGTH);

"""
        prop += "\n"

        # only sends once per cycle
        prop += "// Send once per cycle\n"
        for i in range(self.num_nodes):
            prop += f"""\
property r{i}SendAtMostOnceNorth = A[](sendCounts[{i}].counts[NORTH] <= 1);
property r{i}SendAtMostOnceWest  = A[](sendCounts[{i}].counts[WEST]  <= 1);
property r{i}SendAtMostOnceEast  = A[](sendCounts[{i}].counts[EAST]  <= 1);
property r{i}SendAtMostOnceSouth = A[](sendCounts[{i}].counts[SOUTH] <= 1);
property r{i}SendAtMostOnceLocal = A[](sendCounts[{i}].counts[LOCAL] <= 1);

"""
        return prop

    @add_info
    def properties(self, ptype: PropertyType, *, clk_low: int = 0, clk_high: int = 100, stride: int = 1) -> str:
        properties: str = ""

        if ptype == PropertyType.NO_PROPS:
            return properties
        
        if ptype == PropertyType.RESISTIVE or ptype == PropertyType.BOTH_RI:
            properties += self.resistive_range(clk_low, clk_high, stride)
        
        if ptype == PropertyType.INDUCTIVE or ptype == PropertyType.BOTH_RI:
            properties += self.inductive_range(clk_low, clk_high, stride)
        
        if ptype == PropertyType.FUNCTION:
            properties += self.correctness()
        
        return properties