option "dtmc";

//----- VARIABLES -----

// Test a "central" router that has 4 neighbors
const int NOC_MAX_ID = 8;

// #CUSTOMIZE this value changes the buffer length of all buffers.
const int BUFFER_LENGTH = 4;

// #CUSTOMIZE the number of buffers a router must service before noise will be incramented.
const int ACTIVITY_THRESH = 3;

// #CUSTOMIZE these values change the frequency with witch flits are injected.
const int INJECTION_RATE_NUMERATOR = 3;
const int INJECTION_RATE_DENOMINATOR =10;

// #CUSTOMIZE this is the upper bound of cycles run before quiting.
int(0..INJECTION_RATE_DENOMINATOR) clk = 0;
transient int(0..1) clk_indicator;

const int MAX_CLK_CYCLES = 1;
int(0..MAX_CLK_CYCLES) global_clk_count = 0;

// #CUSTOMIZE this is the upper threshoold for noise detected in the system.
const int RESISTIVE_NOISE_THRESH = 1;
const int INDUCTIVE_NOISE_THRESH = 1;

// These are for tracking resistive and inductive noise and must be initialized to 0.
int resistiveNoise = 0;
int inductiveNoise = 0;

// These values are enumerations and are NOT to be changed
const int NORTH = 0;
const int WEST = 1;
const int EAST = 2;
const int SOUTH = 3;
const int LOCAL = 4;
const int NO_CONNECT = -1;

/***********
[info][section start] Section automatically generated by `datatypes()` in 'noc.py'
***********/
datatype buffer = {
    int(0..NOC_MAX_ID) hd,
    buffer option tl
};

datatype channel = {
    buffer option buffer,
    bool serviced,
    bool isEmpty,
    bool isFull
};

datatype router = {
    channel[] channels,
    int(-1..NOC_MAX_ID)[] ids,
    int(0..4)[] priority_list,
    int(0..4)[] priority_list_temp,
    int(0..4) serviced_index,
    int(0..4) unserviced_index,
    int(0..5) total_unserviced,
    bool[] used
};

action tick;
action sync;

/***********
[info][section end] Section automatically generated by `datatypes()`
***********/

// In this abstract model we actually only really care about routers 1, 3, 4, 5, and 7
// because we are only looking at the abstracted central router.
// The diagram below demonstrates this. We are testing router 4, and we have abstract
// versions of router 1, 3, 5, and 7. We don't actually care about routers 0, 2, 6
// and 8, so we don't need to initialize them here.
/*
(0)  1   (2)
     |
3 -- 4 -- 5
     |
(6)  7   (8)
*/
router[] noc = [
router {}, // R0 - don't use
router { // R1
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}, // N
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}, // W
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}, // E
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}, // S
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],// L
    ids: [NO_CONNECT, 0, 2, 4],
    used: [false, false, false, false, false]
},
router {}, // R2 - Don't use
router { // R3
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [0, NO_CONNECT, 4, 6],
    used: [false, false, false, false, false]
},
router { // R4
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [1, 3, 5, 7],
    priority_list: [NORTH, EAST, SOUTH, WEST, LOCAL],
    priority_list_temp: [NORTH, EAST, SOUTH, WEST, LOCAL],
    serviced_index: 0,
    unserviced_index: 0,
    total_unserviced: 0,
    used: [false, false, false, false, false]
},
router { // R5
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [2, 4, NO_CONNECT, 8],
    used: [false, false, false, false, false]
},
router {}, // R6 - Don't use
router { // R7
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [4, 6, 8, NO_CONNECT],
    used: [false, false, false, false, false]
},
router {} // R8 - don't use
];

/***********
[info][section start] Section automatically generated by `functions()` in 'noc.py'
***********/
// Calculate length of list
function int len(buffer option ls) = if ls == none then 0 else 1 + len(ls!.tl);

// Tell if the buffer is full
function bool isBufferFull(buffer option ls) = len(ls) >= BUFFER_LENGTH;

// Get the mirror direction
function int getDestinationChannel(int dir) =
    if dir == NORTH then SOUTH
    else if dir == WEST then EAST
    else if dir == EAST then WEST
    else if dir == SOUTH then NORTH
    else -1;

// Determine if the flits destination is in the same column as the current router
function int getColumnShift(int id, int dst) =
(dst % ((int)sqrt(NOC_MAX_ID + 1))) - (id % ((int)sqrt(NOC_MAX_ID + 1)));

// Return the front of the queue
function int peekFront(buffer option ls) =
    if ls == none then -1
    else if ls!.tl == none then ls!.hd
    else peekFront(ls!.tl);

// Add a flit to the buffer
function buffer option enqueue(int n, buffer option ls) =
    if len(ls) == BUFFER_LENGTH then ls
    else some(buffer {
        hd: n,
        tl: ls
    });

// Remove a flit from the buffer
function buffer option dequeue(buffer option ls) =
    if ls == none then none
    else if ls!.tl == none then none
    else some(buffer {
        hd: ls!.hd,
        tl: dequeue(ls!.tl)
    });

// Returns True if the buffer `ls` contains `id`, otherwise returns false 
function bool contains(int id, buffer option ls) =
	if ls == none then false 
    else if ls!.hd == id then true
	else contains(id, ls!.tl);

/***********
[info][section end] Section automatically generated by `functions()`
***********/

// property neverGeneratesFlitsForSelf0 = A[](!(contains(0, noc[4].channels[LOCAL].buffer)));

property alwaysContainsNorth    = A[](noc[4].priority_list[0] == NORTH || noc[4].priority_list[1] == NORTH || noc[4].priority_list[2] == NORTH || noc[4].priority_list[3] == NORTH || noc[4].priority_list[4] == NORTH);
property alwaysContainsEast     = A[](noc[4].priority_list[0] == EAST  || noc[4].priority_list[1] == EAST  || noc[4].priority_list[2] == EAST  || noc[4].priority_list[3] == EAST  || noc[4].priority_list[4] == EAST);
property alwaysContainsSouth    = A[](noc[4].priority_list[0] == SOUTH || noc[4].priority_list[1] == SOUTH || noc[4].priority_list[2] == SOUTH || noc[4].priority_list[3] == SOUTH || noc[4].priority_list[4] == SOUTH);
property alwaysContainsWest     = A[](noc[4].priority_list[0] == WEST  || noc[4].priority_list[1] == WEST  || noc[4].priority_list[2] == WEST  || noc[4].priority_list[3] == WEST  || noc[4].priority_list[4] == WEST);
property alwaysContainsLocal    = A[](noc[4].priority_list[0] == LOCAL || noc[4].priority_list[1] == LOCAL || noc[4].priority_list[2] == LOCAL || noc[4].priority_list[3] == LOCAL || noc[4].priority_list[4] == LOCAL);
property allPrioritiesAreUnique = A[]((noc[4].priority_list[0] != noc[4].priority_list[1]) &&
									  (noc[4].priority_list[0] != noc[4].priority_list[2]) && 
									  (noc[4].priority_list[0] != noc[4].priority_list[3]) && 
									  (noc[4].priority_list[0] != noc[4].priority_list[4]) && 
									  (noc[4].priority_list[1] != noc[4].priority_list[2]) && 
									  (noc[4].priority_list[1] != noc[4].priority_list[3]) && 
									  (noc[4].priority_list[1] != noc[4].priority_list[4]) && 
									  (noc[4].priority_list[2] != noc[4].priority_list[3]) && 
									  (noc[4].priority_list[2] != noc[4].priority_list[4]) && 
									  (noc[4].priority_list[3] != noc[4].priority_list[4]));

/***********
[info][section start] Section automatically generated by `processes()` in 'noc.py'
***********/
process GenerateFlits(int id) {
    int(0..NOC_MAX_ID) destination;

    if (clk < INJECTION_RATE_NUMERATOR) {
        // Add the new flit to the local buffer
        // If the destination is greater than or equal to the ID, we shift it
        // up by one to exclude the possiblity of sending a flit to ourselves
        {=
            0: destination = DiscreteUniform(0, NOC_MAX_ID - 1),
            1: noc[id].channels[LOCAL].buffer = 
                enqueue(destination >= id ? 
                            destination + 1 : 
                            destination, noc[id].channels[LOCAL].buffer)
        =}
    }
    else {
        tau
    }
}

process PrepRouter(int id){
    // Prep all the channels
    {=
        // North Channel (0)
        noc[id].channels[NORTH].isEmpty = len(noc[id].channels[NORTH].buffer) == 0,
        noc[id].channels[NORTH].isFull = isBufferFull(noc[id].channels[NORTH].buffer),

        // WEST Channel (1)
        noc[id].channels[WEST].isEmpty = len(noc[id].channels[WEST].buffer) == 0,
        noc[id].channels[WEST].isFull = isBufferFull(noc[id].channels[WEST].buffer),

        // East Channel (2)
        noc[id].channels[EAST].isEmpty = len(noc[id].channels[EAST].buffer) == 0,
        noc[id].channels[EAST].isFull = isBufferFull(noc[id].channels[EAST].buffer),

        // South Channel (3)
        noc[id].channels[SOUTH].isEmpty = len(noc[id].channels[SOUTH].buffer) == 0,
        noc[id].channels[SOUTH].isFull = isBufferFull(noc[id].channels[SOUTH].buffer),

        // Local Channel (4)
        noc[id].channels[LOCAL].isEmpty = len(noc[id].channels[LOCAL].buffer) == 0,
        noc[id].channels[LOCAL].isFull = isBufferFull(noc[id].channels[LOCAL].buffer)
    =}
}

// Send flit to northern router. src and dst are channels (ie NORTH, WEST, EAST, SOUTH, LOCAL), NOT the actual router ids!
process Send(int id, int ch, int dir){
    // We want to chech the final destination buffer of the router we are headed into, to see if it is full
    int(-1..3) dst;
    {=
        // A flit going from router 0 to router 1 leaves 0 from the SOUTH and enters 1 from the NORTH.
        dst = getDestinationChannel(dir)
    =};

    // If the destination is not full, and the channel has not been used in this cycle, then service the buffer
    if(!noc[noc[id].ids[dir]].channels[dst].isFull && !noc[id].used[dir]){
        {=
            // First, add flit to destination buffer
            1: noc[noc[id].ids[dir]].channels[dst].buffer =
                enqueue(peekFront(noc[id].channels[ch].buffer), noc[noc[id].ids[dir]].channels[dst].buffer),

            // Then, remove it from the source buffer
            2: noc[id].channels[ch].buffer = dequeue(noc[id].channels[ch].buffer),

            // Mark that output as used and that channel as serviced
            4: noc[id].used[dir] = true,
            4: noc[id].channels[ch].serviced = true
        =}
    }
    // Otherwise, increment total unserviced buffers
    else{
        {=
            noc[id].total_unserviced++
        =}
    }
}

// Advance flits to respective buffers
process AdvanceFlits(int id, int ch){
    // If flit needs to stay on this row
    if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) == 0){
        // Send it north
        if(peekFront(noc[id].channels[ch].buffer) < id){
            Send(id, ch, NORTH)
        }
        // Or send it south
        else{
            Send(id, ch, SOUTH)
        }
    }
    // Else, if flit needs to go west
    else if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) < 0){
        Send(id, ch, WEST)
    }
    // Else, flit needs to go east
    else{
        Send(id, ch, EAST)
    }
}

// Update a specific channel
process AdvanceChannel(int id, int ch){
    // If this channel was not assigned a neighbor or if it is
    // empty, then mark it as serviced and move on to the next one
    if ((ch != 4 && noc[id].ids[ch] == NO_CONNECT) || noc[id].channels[ch].isEmpty == true) {
        {=
            // Mark the channel as serviced
            noc[id].channels[ch].serviced = true
        =}
    }
    // If the flit has reached its destination...
    else if (peekFront(noc[id].channels[ch].buffer) == id) {
        {=
            /* -- if the locan channel has not been used this clock cycle -- */
            // Mark the channel as serviced and used
            noc[id].channels[ch].serviced = !noc[id].used[LOCAL],
            noc[id].used[LOCAL] = !noc[id].used[LOCAL],

            // Remove this flit. It has reached its destination
            noc[id].channels[ch].buffer = !noc[id].used[LOCAL] ? dequeue(noc[id].channels[ch].buffer) : noc[id].channels[ch].buffer,

            /* -- if the locan channel has been used this clock cycle -- */
            // Otherwise, increment total unserviced buffers
            noc[id].total_unserviced = !noc[id].used[LOCAL] ? noc[id].total_unserviced : noc[id].total_unserviced + 1
        =}
    }
    // Otherwise, the flit must be for another router
    else {
        AdvanceFlits(id, ch)
    }
}

// Update the directions of the next flits in the buffers
process AdvanceRouter(int id){
    AdvanceChannel(id, noc[id].priority_list[0]);
    AdvanceChannel(id, noc[id].priority_list[1]);
    AdvanceChannel(id, noc[id].priority_list[2]);
    AdvanceChannel(id, noc[id].priority_list[3]);
    AdvanceChannel(id, noc[id].priority_list[4])
}

process UpdatePriorityList(int id, int i){
    if (noc[id].channels[noc[id].priority_list[i]].serviced) {
        {=
            0: noc[id].priority_list_temp[noc[id].total_unserviced + noc[id].serviced_index] = noc[id].priority_list[i],
            1: noc[id].serviced_index++
        =}
    }
    else {
        {=
            0: noc[id].priority_list_temp[noc[id].unserviced_index] = noc[id].priority_list[i],
            1: noc[id].unserviced_index++
        =}
    }
}

// Update priority list
process UpdatePiority(int id) {
    // Reset all of the temp values
    {=
        noc[id].priority_list_temp = [0, 0, 0, 0, 0],
        noc[id].serviced_index = 0,
        noc[id].unserviced_index = 0
    =};

    // Update the ordering of priorities in the lists
    UpdatePriorityList(id, 0);
    UpdatePriorityList(id, 1);
    UpdatePriorityList(id, 2);
    UpdatePriorityList(id, 3);
    UpdatePriorityList(id, 4);

    {=
        // Make our next priority list the current priority list
        noc[id].priority_list = noc[id].priority_list_temp,

        // Reset the used and serviced variables
        noc[id].channels[0].serviced = false,
        noc[id].channels[1].serviced = false,
        noc[id].channels[2].serviced = false,
        noc[id].channels[3].serviced = false,
        noc[id].channels[4].serviced = false,
        noc[id].total_unserviced = 0,
        noc[id].used = [false, false, false, false, false]
    =}
}

// Process for behavior
process RouterBehavior(int id) {
    // Run
    GenerateFlits(id);
    // Determine what channels will send this cycle
    PrepRouter(id);

    do{
        sync;
        // Send the flits
        AdvanceRouter(id);
        // Update the priority list
        UpdatePiority(id);

        // no noise tracking because we are abstracting that away :)

        tick;
        // Generate new flits
        GenerateFlits(id);
        // Determine what channels will send this cycle
        PrepRouter(id);

        if (global_clk_count < MAX_CLK_CYCLES) {
            tau
        } else {
            stop
        }
    }
}

// For syncing parallell processes
process Clock() {
    tick {= clk = (clk + 1) % INJECTION_RATE_DENOMINATOR, clk_indicator = 1, global_clk_count++ =};
    
    if (global_clk_count < MAX_CLK_CYCLES) {
        Clock()
    } else {
        stop
    }
}
/***********
[info][section end] Section automatically generated by `processes()`
***********/

// This function takes the given router and returns the channel by which it should send
// a value to the router (R4)
function int getNeighborChannel(int id) = 
    if id == 1 then SOUTH
    else if id == 3 then EAST
    else if id == 5 then WEST
    else if id == 7 then NORTH
    else -1;

// Simplified neighbor model, performs some actions similar to that of the "RouterBehavior"
// process, but doesn't interact with anyone except the test router (in this case R4)
process NeighborBehavior(int id) {
    // We still need to generate flits, but we do it simpler than the
    // RouterBehavior process. Either we generate a flit destined for 
    // R4 (the test router), or we don't.
    alt {
        // Note: enqueue's ipml ensures buffer length is maintained
    ::	{= noc[id].channels[LOCAL].buffer =
                enqueue(4, noc[id].channels[LOCAL].buffer) =}
    ::	tau
    };

    // We still want to prep this router
    {=
        // Prep the channel that receives from R4
        noc[id].channels[getNeighborChannel(id)].isEmpty = len(noc[id].channels[getNeighborChannel(id)].buffer) == 0,
        noc[id].channels[getNeighborChannel(id)].isFull = isBufferFull(noc[id].channels[getNeighborChannel(id)].buffer),
        
        // Prep the local channel
        noc[id].channels[LOCAL].isEmpty = len(noc[id].channels[LOCAL].buffer) == 0,
        noc[id].channels[LOCAL].isFull = isBufferFull(noc[id].channels[LOCAL].buffer)
    =};

    // We model the same loop so that this "neighbor behavior" still matches up with
    // the original model
    do {
        sync;
        // We know that we need to send this guy in only one direction, so we
        // don't need to mess around with the priority list or anything like
        // that
        if (!noc[id].channels[LOCAL].isEmpty) {
            Send(id, LOCAL, getNeighborChannel(id))
        } else { 
            tau 
        };

        // Need to reset the used and serviced vars
        {=
            noc[id].channels[getNeighborChannel(id)].serviced = false,
            noc[id].total_unserviced = 0,
            noc[id].used = [false, false, false, false, false]
        =};

        tick;

        // regenerate flits
        alt {
            // Note: enqueue's ipml ensures buffer length is maintained
        ::	{= noc[id].channels[LOCAL].buffer =
                    enqueue(4, noc[id].channels[LOCAL].buffer) =}
        ::	tau
        };

        // reprep the router
        {=
            // Prep the channel that receives from R4
            noc[id].channels[getNeighborChannel(id)].isEmpty = len(noc[id].channels[getNeighborChannel(id)].buffer) == 0,
            noc[id].channels[getNeighborChannel(id)].isFull = isBufferFull(noc[id].channels[getNeighborChannel(id)].buffer),
            
            // Prep the local channel
            noc[id].channels[LOCAL].isEmpty = len(noc[id].channels[LOCAL].buffer) == 0,
            noc[id].channels[LOCAL].isFull = isBufferFull(noc[id].channels[LOCAL].buffer)
        =}
    }
}

// Here we only model one router (R4) and we then model it's neighbors using the 
// simplified neighbor model
par {
    :: Clock()
    :: RouterBehavior(4)
    :: NeighborBehavior(1)
    :: NeighborBehavior(3)
    :: NeighborBehavior(5)
    :: NeighborBehavior(7)
}

