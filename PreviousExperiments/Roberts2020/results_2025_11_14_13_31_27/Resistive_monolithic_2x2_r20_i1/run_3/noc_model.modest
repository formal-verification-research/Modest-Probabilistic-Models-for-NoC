/* 
Monolithic NoC model
Author:
  Riley Roberts
  Jonah Boe
  Nick Waddoups

Edit history:
  Nick Waddoups, 2025: Setup file to regenerate reproducible results
*/
/*
NoC router IDs
	0 - 1
	|   |
	2 - 3
*/

option "dtmc";

//Top level varables
const int BUFFERLENGTH = 3; //Each buffer actually has length of BUFFERLENGTH + 1 because one directionue is stored in the arbiter itself for easy use when routing.
const int NOCSIZE = 2;
const int INJECTIONRATENUMERATOR = 3;
const int INJECTIONRATEDENOMINATOR = 10;

const int ACTIVITY_THRESH = 3;
const int RESISTIVE_THRESH;
const int INDUCTIVE_THRESH;

transient int(0..1) clk;

datatype intlist = {
	int(0..((NOCSIZE*NOCSIZE)-1)) hd,
	intlist option tl
};

// Datatype for a channel with the next buffer directionue, id of the buffer,
// whether the buffer was serviced last clock cycle or not, and the priority
// number of the buffer
datatype channel = {
	int(-1..4) direction,
	bool serviced,
	int(0..2) priority,
	intlist option buff
};

// Datatype for a router, includes router-specific variables and an array of buffers
datatype router = {
	int(0..3) unserviced,
	int(0..3) totalUnserviced,
	int(0..3) thisActivity,
	int(0..3) lastActivity,
	channel[] channelArray,
	channel[] temp,
	int(0..2) localPos,
	int(0..2) nsPos,
	int(0..2) ewPos /*int[] bufferID*/
};

// Noise counters 
int(0..) resistiveNoise = 0;
int(0..) inductiveNoise = 0;

router[] noc = [
	router {unserviced:0},
	router {unserviced:0},
	router {unserviced:0},
	router {unserviced:0}
];

action tick;

// ------ Begin: function definitions ------- 
// Calculate length of list:
// "!" accesses the value of a non-empty option (causes an error if the option is empty)
function int len(intlist option ls) =
	if ls == none 
	then 0 
	else 1 + len(ls!.tl); 

// Return the front of the queue, i.e., the last element of the given integer list.
// No changes are made to the list.
function int peekFront(intlist option ls) =
	if ls == none then -1
	else if ls!.tl == none then ls!.hd
	else peekFront(ls!.tl);

//Remove the front of the queue, i.e., the last element of the given integer list.
// Return the modified list.
function intlist option dequeue(intlist option ls) = 
	if ls == none then none
	else if	ls!.tl == none then none 
	else some(intlist { hd: ls!.hd, tl: dequeue(ls!.tl) });																		// Remove the last item from the tail

//Insert a new entry n as the head of the list ls. If ls has already reached its
// capacity before adding n, return ls; otherwise, return modified ls with n as
// its head. 
function intlist option enqueue(int n, intlist option ls) = 
	if len(ls) == BUFFERLENGTH then ls
	else some(intlist { hd: n, tl: ls });		 

//Routing function	(x-y routing)
function int route(int dest, int routerID) =
	if dest == -1 then -1//no flit
	else if (dest == routerID) then 4//local
	else if (dest % NOCSIZE) > (routerID % NOCSIZE) then 1/*east*/
	else if (dest % NOCSIZE) < (routerID % NOCSIZE) then 3/*west*/
	else if (dest / NOCSIZE) > (routerID / NOCSIZE) then 2/*south*/
	else if (dest / NOCSIZE) < (routerID / NOCSIZE) then 0/*north*/
	else 4//local
	;

function bool checkNotFull(int direction, int routerID) = 																		// Check if input buffer of input NoC is full
	if direction == -1 then true //no flit
	else if (direction == 0 && routerID - NOCSIZE >= 0) 
		then len(noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].nsPos].buff) < BUFFERLENGTH
	else if (direction == 1  && routerID + 1 <= 3) 
		then len(noc[routerID + 1].channelArray[noc[routerID + 1].ewPos].buff) < BUFFERLENGTH
	else if (direction == 2  && routerID + NOCSIZE <= 3) 
		then len(noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].nsPos].buff) < BUFFERLENGTH
	else if (direction == 3  && routerID - 1 >= 0) 
		then len(noc[routerID - 1].channelArray[noc[routerID - 1].ewPos].buff) < BUFFERLENGTH
	else if direction == 4 
		then true //send local
	else false //catch all case
	;
	
function int(0..1) checkNotFullIncrement(int direction, int routerID) = 
	(checkNotFull(direction, routerID)) ? 0 : 1;			// CheckNotFull, but returning int 0 or 1

// ------ Begin: process definitions ------
//---- Parallel Processes ----
process Clock() {	
	tick {= clk = 1 =};
	Clock()
}

process Top() {
	initialize();
	Populate();
	initialRoute(0);
	initialRoute(1);
	initialRoute(2);
	initialRoute(3);
	do {
		Arbiter_corner(0);																										// Resolve shifting the input buffers by one
		Arbiter_corner(1);
		Arbiter_corner(2);
		Arbiter_corner(3);	
		
		Measure_noise(0);
		Measure_noise(1);
		Measure_noise(2);
		Measure_noise(3);

		tick;
		
		Populate();																												// Populate new flits
		
		updateDestination(0, 0);																								// Update where the flits that have been serviced now
		updateDestination(1, 0);																								// need to go
		updateDestination(2, 0);
		
		updateDestination(0, 1);
		updateDestination(1, 1);
		updateDestination(2, 1);
		
		updateDestination(0, 2);
		updateDestination(1, 2);
		updateDestination(2, 2);
		
		updateDestination(0, 3);
		updateDestination(1, 3);
		updateDestination(2, 3)
	}
}

process Populate() {
	if ((clk % INJECTIONRATEDENOMINATOR) < INJECTIONRATENUMERATOR){																// Flit injection happens every n/d clk cycles
		palt {
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(1, noc[0].channelArray[noc[0].localPos].buff) =}		// A new flit produced by noc 0 has a 1 in 3 chanc of
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(2, noc[0].channelArray[noc[0].localPos].buff) =}		// any of the other 3 oncs being its endpoint
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(3, noc[0].channelArray[noc[0].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(0, noc[1].channelArray[noc[1].localPos].buff) =}
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(2, noc[1].channelArray[noc[1].localPos].buff) =}
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(3, noc[1].channelArray[noc[1].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(0, noc[2].channelArray[noc[2].localPos].buff) =}
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(1, noc[2].channelArray[noc[2].localPos].buff) =}
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(3, noc[2].channelArray[noc[2].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(0, noc[3].channelArray[noc[3].localPos].buff) =}
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(1, noc[3].channelArray[noc[3].localPos].buff) =}
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(2, noc[3].channelArray[noc[3].localPos].buff) =}
		}
	} else {
		tau
	}
}


//---- Sub processes ----
process Arbiter_corner(int routerID) {
	//Service buffers-------------------------------------------------------------------------------------------------------
		
		//Buffer priority 0
		//<Service Buffer channelArray[0]>--------------------------------------------------------
		{=
		noc[routerID].channelArray[0].serviced = checkNotFull(noc[routerID].channelArray[0].direction, routerID),				// If buffer between ID and direction is not full...
		noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[0].direction, routerID),				// add one more to the buffer if a new flit has been
		noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[0].direction, routerID)					// generated in that direction
		=};
		
		//<Service buffer channelArray[1]> ------------------------------------------------------
		if (noc[routerID].channelArray[1].direction == -1 || noc[routerID].channelArray[1].direction != noc[routerID].channelArray[0].direction) {			//If buffer channelArray[1] does not conflict with channelArray[0]
			{= 	//Service Buffer
			noc[routerID].channelArray[1].serviced = checkNotFull(noc[routerID].channelArray[1].direction, routerID),
			noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[1].direction, routerID),
			noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[1].direction, routerID)
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[1].serviced = false,
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++ 		//Increment unserviced
			=}
		};
		
		//<Service buffer channelArray[2]> --------------------------------------------------------
		//If buffer channelArray[2] does not conflict with channelArray[1] or channelArray[0]
		if (noc[routerID].channelArray[2].direction == -1 || noc[routerID].channelArray[2].direction != noc[routerID].channelArray[1].direction && noc[routerID].channelArray[2].direction != noc[routerID].channelArray[0].direction){	
			{= 	//Service Buffer
			noc[routerID].channelArray[2].serviced = checkNotFull(noc[routerID].channelArray[2].direction, routerID),
			noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[2].direction, routerID),
			noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[2].direction, routerID)
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[2].serviced = false, 
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++			//Increment unserviced
			=}
		};
	
		//Set priority directions for the next run and update the direction of the buffers----------------------------------------------
		setPriority(0, routerID);
		setPriority(1, routerID);
		setPriority(2, routerID);
		
		// need to update the bufferID array
		// test update for router 0
		{=
			noc[routerID].ewPos = noc[routerID].channelArray[noc[routerID].ewPos].priority,
			noc[routerID].nsPos = noc[routerID].channelArray[noc[routerID].nsPos].priority,
			noc[routerID].localPos = noc[routerID].channelArray[noc[routerID].localPos].priority,
			
			noc[routerID].totalUnserviced = 0			//reset Total Unserviced to 0 for next cycle
		=};
		
		//Rewrite buffer array with new priority values-------------------------------------------------------------------------
		{= 
		noc[routerID].temp[noc[routerID].channelArray[0].priority] = noc[routerID].channelArray[0],
		noc[routerID].temp[noc[routerID].channelArray[1].priority] = noc[routerID].channelArray[1],
		noc[routerID].temp[noc[routerID].channelArray[2].priority] = noc[routerID].channelArray[2]//,
		
		//noc[routerID].bufferID[noc[routerID].channelArray[0].id] = noc[routerID].channelArray[0].priority,
		//noc[routerID].bufferID[noc[routerID].channelArray[1].id] = noc[routerID].channelArray[1].priority,
		//noc[routerID].bufferID[noc[routerID].channelArray[2].id] = noc[routerID].channelArray[2].priority
		=};
		
		{= noc[routerID].channelArray = noc[routerID].temp =}
}
	
// Measure PSN
process Measure_noise(int routerID)
{
	{=
		0: resistiveNoise = noc[routerID].thisActivity >= ACTIVITY_THRESH
			? resistiveNoise + 1
			: resistiveNoise,
		0: inductiveNoise = abs(noc[routerID].lastActivity - noc[routerID].thisActivity) >= ACTIVITY_THRESH
			? inductiveNoise + 1
			: inductiveNoise,
		
		1: noc[routerID].lastActivity = noc[routerID].thisActivity,
		1: noc[routerID].thisActivity = 0
	=}
}

//initialize values --------------------------------------------------------------------------------------------------------------------------------------------
process initialize() {
	initialize_node_nw(0);
	initialize_node_ne(1);
	initialize_node_sw(2);
	initialize_node_se(3)
}

process initialize_node_nw(int routerID) {
	channel east, south, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [east, south, local, spare1, spare2, spare3],
	noc[routerID].temp = [east, south, local, spare1, spare2, spare3],
	
	noc[routerID].ewPos = 0,
	noc[routerID].nsPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0/**/, 0, 1, 0/**/, 2],
	
	//noc[routerID].channelArray[0].id = 1, 
	//noc[routerID].channelArray[1].id = 2, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_ne(int routerID) {
	channel south, west, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [south, west, local, spare1, spare2, spare3],
	noc[routerID].temp = [south, west, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0/**/, 0/**/, 0, 1, 2],
	
	//noc[routerID].channelArray[0].id = 2, 
	//noc[routerID].channelArray[1].id = 3, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_sw(int routerID) {
	channel north, east, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [north, east, local, spare1, spare2, spare3],
	noc[routerID].temp = [north, east, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0, 1, 0/**/, 0/**/, 2],
	
	//noc[routerID].channelArray[0].id = 0, 
	//noc[routerID].channelArray[1].id = 1, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_se(int routerID) {
	channel north, west, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [north, west, local, spare1, spare2, spare3],
	noc[routerID].temp = [north, west, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0, 0/**/, 0/**/, 1, 2],
	
	//noc[routerID].channelArray[0].id = 0, 
	//noc[routerID].channelArray[1].id = 3, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
	
}

//runs routing after initial setup (for testing)
process initialRoute(int routerID) {
	{=
	noc[routerID].channelArray[0].direction = route(peekFront(noc[routerID].channelArray[0].buff), routerID),
	noc[routerID].channelArray[1].direction = route(peekFront(noc[routerID].channelArray[1].buff), routerID),
	noc[routerID].channelArray[2].direction = route(peekFront(noc[routerID].channelArray[2].buff), routerID)
	=}
}


//Sets the new priority of buffer channelArray[i] and forwards the destination if the buffer was serviced ------------------------------------------------------------------
process setPriority(int i, int routerID) {
	if (noc[routerID].channelArray[i].serviced == true) {
		if (noc[routerID].channelArray[i].direction == -1){ tau }
		else if(noc[routerID].channelArray[i].direction == 4) {			//Send in the local direction
			{= 
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
			noc[routerID].thisActivity++
			=}			//flit delivered
		}
		else if (noc[routerID].channelArray[i].direction == 0) {			//Send in the north direction
			sendNorth(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 1) {			//Send in the east direction
			sendEast(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 2) {			//Send in the south direction
			sendSouth(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 3) {			//Send in the west direction
			sendWest(routerID, noc[routerID].channelArray[i].buff);
			{= 
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else { tau };
		
		{=																								
		noc[routerID].channelArray[i].direction = -1,								
		noc[routerID].channelArray[i].priority = i + noc[routerID].unserviced 				//Set new priority                     
		=}
	}
	else {
		{= 
		noc[routerID].channelArray[i].priority = noc[routerID].totalUnserviced - noc[routerID].unserviced,		//Set new priority
		noc[routerID].unserviced-- 						//decrement unserviced
		=}
	}
}

//Updates the destination from the buffer if the buffer was serviced
process updateDestination(int i , int routerID) {
	if (noc[routerID].channelArray[i].serviced == true) {
		{=
		noc[routerID].channelArray[i].direction = route(peekFront(noc[routerID].channelArray[i].buff), routerID)		//Update direction from buffer
		=}
	} else {
		tau
	}
}

process sendNorth(int routerID, intlist option source) {
	if (routerID == 2) {
		{=
		noc[0].channelArray[noc[0].nsPos].buff = enqueue(peekFront(source), noc[0].channelArray[noc[0].nsPos].buff)
		//,source = dequeue(source)
		=}
	}
	else if (routerID == 3) {
		{=
		noc[1].channelArray[noc[1].nsPos].buff = enqueue(peekFront(source), noc[1].channelArray[noc[1].nsPos].buff)
		//,source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendEast(int routerID, intlist option source) {
	if (routerID == 0) {
		{=
		noc[1].channelArray[noc[1].ewPos].buff = enqueue(peekFront(source), noc[1].channelArray[noc[1].ewPos].buff)
		//,source = dequeue(source)
		=}
	} else if(routerID == 2) {
		{=
		noc[3].channelArray[noc[3].ewPos].buff = enqueue(peekFront(source), noc[3].channelArray[noc[3].ewPos].buff)
		//,source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendSouth(int routerID, intlist option source) {
	if (routerID == 0) {
		{=
		noc[2].channelArray[noc[2].nsPos].buff = enqueue(peekFront(source), noc[2].channelArray[noc[2].nsPos].buff),
		source = dequeue(source)
		=}
	} else if(routerID == 1) {
		{=
		noc[3].channelArray[noc[3].nsPos].buff = enqueue(peekFront(source), noc[3].channelArray[noc[3].nsPos].buff),
		source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendWest(int routerID, intlist option source) {
	if (routerID == 1) {
		{=
		noc[0].channelArray[noc[0].ewPos].buff = enqueue(peekFront(source), noc[0].channelArray[noc[0].ewPos].buff),
		source = dequeue(source)
		=}
	} else if (routerID == 3) {
		{=
		noc[2].channelArray[noc[2].ewPos].buff = enqueue(peekFront(source), noc[2].channelArray[noc[2].ewPos].buff),
		source = dequeue(source)
		=}
	} else {
		tau
	}
}

// ------- End: process definitions -------
par {
::	Clock()
:: 	Top()
}

property R_300 = Pmax(<>[S(clk)<=300] (resistiveNoise >= RESISTIVE_THRESH));
property R_301 = Pmax(<>[S(clk)<=301] (resistiveNoise >= RESISTIVE_THRESH));
property R_302 = Pmax(<>[S(clk)<=302] (resistiveNoise >= RESISTIVE_THRESH));
property R_303 = Pmax(<>[S(clk)<=303] (resistiveNoise >= RESISTIVE_THRESH));
property R_304 = Pmax(<>[S(clk)<=304] (resistiveNoise >= RESISTIVE_THRESH));
property R_305 = Pmax(<>[S(clk)<=305] (resistiveNoise >= RESISTIVE_THRESH));
property R_306 = Pmax(<>[S(clk)<=306] (resistiveNoise >= RESISTIVE_THRESH));
property R_307 = Pmax(<>[S(clk)<=307] (resistiveNoise >= RESISTIVE_THRESH));
property R_308 = Pmax(<>[S(clk)<=308] (resistiveNoise >= RESISTIVE_THRESH));
property R_309 = Pmax(<>[S(clk)<=309] (resistiveNoise >= RESISTIVE_THRESH));
property R_310 = Pmax(<>[S(clk)<=310] (resistiveNoise >= RESISTIVE_THRESH));
property R_311 = Pmax(<>[S(clk)<=311] (resistiveNoise >= RESISTIVE_THRESH));
property R_312 = Pmax(<>[S(clk)<=312] (resistiveNoise >= RESISTIVE_THRESH));
property R_313 = Pmax(<>[S(clk)<=313] (resistiveNoise >= RESISTIVE_THRESH));
property R_314 = Pmax(<>[S(clk)<=314] (resistiveNoise >= RESISTIVE_THRESH));
property R_315 = Pmax(<>[S(clk)<=315] (resistiveNoise >= RESISTIVE_THRESH));
property R_316 = Pmax(<>[S(clk)<=316] (resistiveNoise >= RESISTIVE_THRESH));
property R_317 = Pmax(<>[S(clk)<=317] (resistiveNoise >= RESISTIVE_THRESH));
property R_318 = Pmax(<>[S(clk)<=318] (resistiveNoise >= RESISTIVE_THRESH));
property R_319 = Pmax(<>[S(clk)<=319] (resistiveNoise >= RESISTIVE_THRESH));
property R_320 = Pmax(<>[S(clk)<=320] (resistiveNoise >= RESISTIVE_THRESH));
property R_321 = Pmax(<>[S(clk)<=321] (resistiveNoise >= RESISTIVE_THRESH));
property R_322 = Pmax(<>[S(clk)<=322] (resistiveNoise >= RESISTIVE_THRESH));
property R_323 = Pmax(<>[S(clk)<=323] (resistiveNoise >= RESISTIVE_THRESH));
property R_324 = Pmax(<>[S(clk)<=324] (resistiveNoise >= RESISTIVE_THRESH));
property R_325 = Pmax(<>[S(clk)<=325] (resistiveNoise >= RESISTIVE_THRESH));
property R_326 = Pmax(<>[S(clk)<=326] (resistiveNoise >= RESISTIVE_THRESH));
property R_327 = Pmax(<>[S(clk)<=327] (resistiveNoise >= RESISTIVE_THRESH));
property R_328 = Pmax(<>[S(clk)<=328] (resistiveNoise >= RESISTIVE_THRESH));
property R_329 = Pmax(<>[S(clk)<=329] (resistiveNoise >= RESISTIVE_THRESH));
property R_330 = Pmax(<>[S(clk)<=330] (resistiveNoise >= RESISTIVE_THRESH));
property R_331 = Pmax(<>[S(clk)<=331] (resistiveNoise >= RESISTIVE_THRESH));
property R_332 = Pmax(<>[S(clk)<=332] (resistiveNoise >= RESISTIVE_THRESH));
property R_333 = Pmax(<>[S(clk)<=333] (resistiveNoise >= RESISTIVE_THRESH));
property R_334 = Pmax(<>[S(clk)<=334] (resistiveNoise >= RESISTIVE_THRESH));
property R_335 = Pmax(<>[S(clk)<=335] (resistiveNoise >= RESISTIVE_THRESH));
property R_336 = Pmax(<>[S(clk)<=336] (resistiveNoise >= RESISTIVE_THRESH));
property R_337 = Pmax(<>[S(clk)<=337] (resistiveNoise >= RESISTIVE_THRESH));
property R_338 = Pmax(<>[S(clk)<=338] (resistiveNoise >= RESISTIVE_THRESH));
property R_339 = Pmax(<>[S(clk)<=339] (resistiveNoise >= RESISTIVE_THRESH));
property R_340 = Pmax(<>[S(clk)<=340] (resistiveNoise >= RESISTIVE_THRESH));
property R_341 = Pmax(<>[S(clk)<=341] (resistiveNoise >= RESISTIVE_THRESH));
property R_342 = Pmax(<>[S(clk)<=342] (resistiveNoise >= RESISTIVE_THRESH));
property R_343 = Pmax(<>[S(clk)<=343] (resistiveNoise >= RESISTIVE_THRESH));
property R_344 = Pmax(<>[S(clk)<=344] (resistiveNoise >= RESISTIVE_THRESH));
property R_345 = Pmax(<>[S(clk)<=345] (resistiveNoise >= RESISTIVE_THRESH));
property R_346 = Pmax(<>[S(clk)<=346] (resistiveNoise >= RESISTIVE_THRESH));
property R_347 = Pmax(<>[S(clk)<=347] (resistiveNoise >= RESISTIVE_THRESH));
property R_348 = Pmax(<>[S(clk)<=348] (resistiveNoise >= RESISTIVE_THRESH));
property R_349 = Pmax(<>[S(clk)<=349] (resistiveNoise >= RESISTIVE_THRESH));
property R_350 = Pmax(<>[S(clk)<=350] (resistiveNoise >= RESISTIVE_THRESH));
property R_351 = Pmax(<>[S(clk)<=351] (resistiveNoise >= RESISTIVE_THRESH));
property R_352 = Pmax(<>[S(clk)<=352] (resistiveNoise >= RESISTIVE_THRESH));
property R_353 = Pmax(<>[S(clk)<=353] (resistiveNoise >= RESISTIVE_THRESH));
property R_354 = Pmax(<>[S(clk)<=354] (resistiveNoise >= RESISTIVE_THRESH));
property R_355 = Pmax(<>[S(clk)<=355] (resistiveNoise >= RESISTIVE_THRESH));
property R_356 = Pmax(<>[S(clk)<=356] (resistiveNoise >= RESISTIVE_THRESH));
property R_357 = Pmax(<>[S(clk)<=357] (resistiveNoise >= RESISTIVE_THRESH));
property R_358 = Pmax(<>[S(clk)<=358] (resistiveNoise >= RESISTIVE_THRESH));
property R_359 = Pmax(<>[S(clk)<=359] (resistiveNoise >= RESISTIVE_THRESH));
property R_360 = Pmax(<>[S(clk)<=360] (resistiveNoise >= RESISTIVE_THRESH));
property R_361 = Pmax(<>[S(clk)<=361] (resistiveNoise >= RESISTIVE_THRESH));
property R_362 = Pmax(<>[S(clk)<=362] (resistiveNoise >= RESISTIVE_THRESH));
property R_363 = Pmax(<>[S(clk)<=363] (resistiveNoise >= RESISTIVE_THRESH));
property R_364 = Pmax(<>[S(clk)<=364] (resistiveNoise >= RESISTIVE_THRESH));
property R_365 = Pmax(<>[S(clk)<=365] (resistiveNoise >= RESISTIVE_THRESH));
property R_366 = Pmax(<>[S(clk)<=366] (resistiveNoise >= RESISTIVE_THRESH));
property R_367 = Pmax(<>[S(clk)<=367] (resistiveNoise >= RESISTIVE_THRESH));
property R_368 = Pmax(<>[S(clk)<=368] (resistiveNoise >= RESISTIVE_THRESH));
property R_369 = Pmax(<>[S(clk)<=369] (resistiveNoise >= RESISTIVE_THRESH));
property R_370 = Pmax(<>[S(clk)<=370] (resistiveNoise >= RESISTIVE_THRESH));
property R_371 = Pmax(<>[S(clk)<=371] (resistiveNoise >= RESISTIVE_THRESH));
property R_372 = Pmax(<>[S(clk)<=372] (resistiveNoise >= RESISTIVE_THRESH));
property R_373 = Pmax(<>[S(clk)<=373] (resistiveNoise >= RESISTIVE_THRESH));
property R_374 = Pmax(<>[S(clk)<=374] (resistiveNoise >= RESISTIVE_THRESH));
property R_375 = Pmax(<>[S(clk)<=375] (resistiveNoise >= RESISTIVE_THRESH));
property R_376 = Pmax(<>[S(clk)<=376] (resistiveNoise >= RESISTIVE_THRESH));
property R_377 = Pmax(<>[S(clk)<=377] (resistiveNoise >= RESISTIVE_THRESH));
property R_378 = Pmax(<>[S(clk)<=378] (resistiveNoise >= RESISTIVE_THRESH));
property R_379 = Pmax(<>[S(clk)<=379] (resistiveNoise >= RESISTIVE_THRESH));
property R_380 = Pmax(<>[S(clk)<=380] (resistiveNoise >= RESISTIVE_THRESH));
property R_381 = Pmax(<>[S(clk)<=381] (resistiveNoise >= RESISTIVE_THRESH));
property R_382 = Pmax(<>[S(clk)<=382] (resistiveNoise >= RESISTIVE_THRESH));
property R_383 = Pmax(<>[S(clk)<=383] (resistiveNoise >= RESISTIVE_THRESH));
property R_384 = Pmax(<>[S(clk)<=384] (resistiveNoise >= RESISTIVE_THRESH));
property R_385 = Pmax(<>[S(clk)<=385] (resistiveNoise >= RESISTIVE_THRESH));
property R_386 = Pmax(<>[S(clk)<=386] (resistiveNoise >= RESISTIVE_THRESH));
property R_387 = Pmax(<>[S(clk)<=387] (resistiveNoise >= RESISTIVE_THRESH));
property R_388 = Pmax(<>[S(clk)<=388] (resistiveNoise >= RESISTIVE_THRESH));
property R_389 = Pmax(<>[S(clk)<=389] (resistiveNoise >= RESISTIVE_THRESH));
property R_390 = Pmax(<>[S(clk)<=390] (resistiveNoise >= RESISTIVE_THRESH));
property R_391 = Pmax(<>[S(clk)<=391] (resistiveNoise >= RESISTIVE_THRESH));
property R_392 = Pmax(<>[S(clk)<=392] (resistiveNoise >= RESISTIVE_THRESH));
property R_393 = Pmax(<>[S(clk)<=393] (resistiveNoise >= RESISTIVE_THRESH));
property R_394 = Pmax(<>[S(clk)<=394] (resistiveNoise >= RESISTIVE_THRESH));
property R_395 = Pmax(<>[S(clk)<=395] (resistiveNoise >= RESISTIVE_THRESH));
property R_396 = Pmax(<>[S(clk)<=396] (resistiveNoise >= RESISTIVE_THRESH));
property R_397 = Pmax(<>[S(clk)<=397] (resistiveNoise >= RESISTIVE_THRESH));
property R_398 = Pmax(<>[S(clk)<=398] (resistiveNoise >= RESISTIVE_THRESH));
property R_399 = Pmax(<>[S(clk)<=399] (resistiveNoise >= RESISTIVE_THRESH));