/* 
Monolithic NoC model
Author:
  Riley Roberts
  Jonah Boe
  Nick Waddoups

Edit history:
  Nick Waddoups, 2025: Setup file to regenerate reproducible results
*/
/*
NoC router IDs
	0 - 1
	|   |
	2 - 3
*/

option "dtmc";

//Top level varables
const int BUFFERLENGTH = 3; //Each buffer actually has length of BUFFERLENGTH + 1 because one directionue is stored in the arbiter itself for easy use when routing.
const int NOCSIZE = 2;
const int INJECTIONRATENUMERATOR = 3;
const int INJECTIONRATEDENOMINATOR = 10;

const int ACTIVITY_THRESH = 3;
const int RESISTIVE_THRESH;
const int INDUCTIVE_THRESH;

transient int(0..1) clk;
int(0..INJECTIONRATEDENOMINATOR-1) clk_counter = 0;

datatype intlist = {
	int(0..((NOCSIZE*NOCSIZE)-1)) hd,
	intlist option tl
};

// Datatype for a channel with the next buffer directionue, id of the buffer,
// whether the buffer was serviced last clock cycle or not, and the priority
// number of the buffer
datatype channel = {
	int(-1..4) direction,
	bool serviced,
	int(0..2) priority,
	intlist option buff
};

// Datatype for a router, includes router-specific variables and an array of buffers
datatype router = {
	int(0..3) unserviced,
	int(0..3) totalUnserviced,
	int(0..3) thisActivity,
	int(0..3) lastActivity,
	channel[] channelArray,
	channel[] temp,
	int(0..2) localPos,
	int(0..2) nsPos,
	int(0..2) ewPos /*int[] bufferID*/
};

// Noise counters 
int(0..) resistiveNoise = 0;
int(0..) inductiveNoise = 0;

router[] noc = [
	router {unserviced:0},
	router {unserviced:0},
	router {unserviced:0},
	router {unserviced:0}
];

action tick;

// ------ Begin: function definitions ------- 
// Calculate length of list:
// "!" accesses the value of a non-empty option (causes an error if the option is empty)
function int len(intlist option ls) =
	if ls == none 
	then 0 
	else 1 + len(ls!.tl); 

// Return the front of the queue, i.e., the last element of the given integer list.
// No changes are made to the list.
function int peekFront(intlist option ls) =
	if ls == none then -1
	else if ls!.tl == none then ls!.hd
	else peekFront(ls!.tl);

//Remove the front of the queue, i.e., the last element of the given integer list.
// Return the modified list.
function intlist option dequeue(intlist option ls) = 
	if ls == none then none
	else if	ls!.tl == none then none 
	else some(intlist { hd: ls!.hd, tl: dequeue(ls!.tl) });																		// Remove the last item from the tail

//Insert a new entry n as the head of the list ls. If ls has already reached its
// capacity before adding n, return ls; otherwise, return modified ls with n as
// its head. 
function intlist option enqueue(int n, intlist option ls) = 
	if len(ls) == BUFFERLENGTH then ls
	else some(intlist { hd: n, tl: ls });		 

//Routing function	(x-y routing)
function int route(int dest, int routerID) =
	if dest == -1 then -1//no flit
	else if (dest == routerID) then 4//local
	else if (dest % NOCSIZE) > (routerID % NOCSIZE) then 1/*east*/
	else if (dest % NOCSIZE) < (routerID % NOCSIZE) then 3/*west*/
	else if (dest / NOCSIZE) > (routerID / NOCSIZE) then 2/*south*/
	else if (dest / NOCSIZE) < (routerID / NOCSIZE) then 0/*north*/
	else 4//local
	;

function bool checkNotFull(int direction, int routerID) = 																		// Check if input buffer of input NoC is full
	if direction == -1 then true //no flit
	else if (direction == 0 && routerID - NOCSIZE >= 0) 
		then len(noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].nsPos].buff) < BUFFERLENGTH
	else if (direction == 1  && routerID + 1 <= 3) 
		then len(noc[routerID + 1].channelArray[noc[routerID + 1].ewPos].buff) < BUFFERLENGTH
	else if (direction == 2  && routerID + NOCSIZE <= 3) 
		then len(noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].nsPos].buff) < BUFFERLENGTH
	else if (direction == 3  && routerID - 1 >= 0) 
		then len(noc[routerID - 1].channelArray[noc[routerID - 1].ewPos].buff) < BUFFERLENGTH
	else if direction == 4 
		then true //send local
	else false //catch all case
	;
	
function int(0..1) checkNotFullIncrement(int direction, int routerID) = 
	(checkNotFull(direction, routerID)) ? 0 : 1;			// CheckNotFull, but returning int 0 or 1

// ------ Begin: process definitions ------
//---- Parallel Processes ----
process Clock() {	
	tick {= clk = 1, clk_counter = (clk_counter + 1) % INJECTIONRATEDENOMINATOR =};
	Clock()
}

process Top() {
	initialize();
	Populate();
	initialRoute(0);
	initialRoute(1);
	initialRoute(2);
	initialRoute(3);
	do {
		Arbiter_corner(0);																										// Resolve shifting the input buffers by one
		Arbiter_corner(1);
		Arbiter_corner(2);
		Arbiter_corner(3);	
		
		Measure_noise(0);
		Measure_noise(1);
		Measure_noise(2);
		Measure_noise(3);

		tick;
		
		Populate();																												// Populate new flits
		
		updateDestination(0, 0);																								// Update where the flits that have been serviced now
		updateDestination(1, 0);																								// need to go
		updateDestination(2, 0);
		
		updateDestination(0, 1);
		updateDestination(1, 1);
		updateDestination(2, 1);
		
		updateDestination(0, 2);
		updateDestination(1, 2);
		updateDestination(2, 2);
		
		updateDestination(0, 3);
		updateDestination(1, 3);
		updateDestination(2, 3)
	}
}

process Populate() {
	if ((clk_counter % INJECTIONRATEDENOMINATOR) < INJECTIONRATENUMERATOR){																// Flit injection happens every n/d clk cycles
		palt {
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(1, noc[0].channelArray[noc[0].localPos].buff) =}		// A new flit produced by noc 0 has a 1 in 3 chanc of
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(2, noc[0].channelArray[noc[0].localPos].buff) =}		// any of the other 3 oncs being its endpoint
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(3, noc[0].channelArray[noc[0].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(0, noc[1].channelArray[noc[1].localPos].buff) =}
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(2, noc[1].channelArray[noc[1].localPos].buff) =}
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(3, noc[1].channelArray[noc[1].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(0, noc[2].channelArray[noc[2].localPos].buff) =}
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(1, noc[2].channelArray[noc[2].localPos].buff) =}
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(3, noc[2].channelArray[noc[2].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(0, noc[3].channelArray[noc[3].localPos].buff) =}
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(1, noc[3].channelArray[noc[3].localPos].buff) =}
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(2, noc[3].channelArray[noc[3].localPos].buff) =}
		}
	} else {
		tau
	}
}


//---- Sub processes ----
process Arbiter_corner(int routerID) {
	//Service buffers-------------------------------------------------------------------------------------------------------
		
		//Buffer priority 0
		//<Service Buffer channelArray[0]>--------------------------------------------------------
		{=
		noc[routerID].channelArray[0].serviced = checkNotFull(noc[routerID].channelArray[0].direction, routerID),				// If buffer between ID and direction is not full...
		noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[0].direction, routerID),				// add one more to the buffer if a new flit has been
		noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[0].direction, routerID)					// generated in that direction
		=};
		
		//<Service buffer channelArray[1]> ------------------------------------------------------
		if (noc[routerID].channelArray[1].direction == -1 || noc[routerID].channelArray[1].direction != noc[routerID].channelArray[0].direction) {			//If buffer channelArray[1] does not conflict with channelArray[0]
			{= 	//Service Buffer
			noc[routerID].channelArray[1].serviced = checkNotFull(noc[routerID].channelArray[1].direction, routerID),
			noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[1].direction, routerID),
			noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[1].direction, routerID)
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[1].serviced = false,
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++ 		//Increment unserviced
			=}
		};
		
		//<Service buffer channelArray[2]> --------------------------------------------------------
		//If buffer channelArray[2] does not conflict with channelArray[1] or channelArray[0]
		if (noc[routerID].channelArray[2].direction == -1 || noc[routerID].channelArray[2].direction != noc[routerID].channelArray[1].direction && noc[routerID].channelArray[2].direction != noc[routerID].channelArray[0].direction){	
			{= 	//Service Buffer
			noc[routerID].channelArray[2].serviced = checkNotFull(noc[routerID].channelArray[2].direction, routerID),
			noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[2].direction, routerID),
			noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[2].direction, routerID)
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[2].serviced = false, 
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++			//Increment unserviced
			=}
		};
	
		//Set priority directions for the next run and update the direction of the buffers----------------------------------------------
		setPriority(0, routerID);
		setPriority(1, routerID);
		setPriority(2, routerID);
		
		// need to update the bufferID array
		// test update for router 0
		{=
			noc[routerID].ewPos = noc[routerID].channelArray[noc[routerID].ewPos].priority,
			noc[routerID].nsPos = noc[routerID].channelArray[noc[routerID].nsPos].priority,
			noc[routerID].localPos = noc[routerID].channelArray[noc[routerID].localPos].priority,
			
			noc[routerID].totalUnserviced = 0			//reset Total Unserviced to 0 for next cycle
		=};
		
		//Rewrite buffer array with new priority values-------------------------------------------------------------------------
		{= 
		noc[routerID].temp[noc[routerID].channelArray[0].priority] = noc[routerID].channelArray[0],
		noc[routerID].temp[noc[routerID].channelArray[1].priority] = noc[routerID].channelArray[1],
		noc[routerID].temp[noc[routerID].channelArray[2].priority] = noc[routerID].channelArray[2]//,
		
		//noc[routerID].bufferID[noc[routerID].channelArray[0].id] = noc[routerID].channelArray[0].priority,
		//noc[routerID].bufferID[noc[routerID].channelArray[1].id] = noc[routerID].channelArray[1].priority,
		//noc[routerID].bufferID[noc[routerID].channelArray[2].id] = noc[routerID].channelArray[2].priority
		=};
		
		{= noc[routerID].channelArray = noc[routerID].temp =}
}
	
// Measure PSN
process Measure_noise(int routerID)
{
	{=
		0: resistiveNoise = noc[routerID].thisActivity >= ACTIVITY_THRESH
			? resistiveNoise + 1
			: resistiveNoise,
		0: inductiveNoise = abs(noc[routerID].lastActivity - noc[routerID].thisActivity) >= ACTIVITY_THRESH
			? inductiveNoise + 1
			: inductiveNoise,
		
		1: noc[routerID].lastActivity = noc[routerID].thisActivity,
		1: noc[routerID].thisActivity = 0
	=}
}

//initialize values --------------------------------------------------------------------------------------------------------------------------------------------
process initialize() {
	initialize_node_nw(0);
	initialize_node_ne(1);
	initialize_node_sw(2);
	initialize_node_se(3)
}

process initialize_node_nw(int routerID) {
	channel east, south, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [east, south, local, spare1, spare2, spare3],
	noc[routerID].temp = [east, south, local, spare1, spare2, spare3],
	
	noc[routerID].ewPos = 0,
	noc[routerID].nsPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0/**/, 0, 1, 0/**/, 2],
	
	//noc[routerID].channelArray[0].id = 1, 
	//noc[routerID].channelArray[1].id = 2, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_ne(int routerID) {
	channel south, west, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [south, west, local, spare1, spare2, spare3],
	noc[routerID].temp = [south, west, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0/**/, 0/**/, 0, 1, 2],
	
	//noc[routerID].channelArray[0].id = 2, 
	//noc[routerID].channelArray[1].id = 3, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_sw(int routerID) {
	channel north, east, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [north, east, local, spare1, spare2, spare3],
	noc[routerID].temp = [north, east, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0, 1, 0/**/, 0/**/, 2],
	
	//noc[routerID].channelArray[0].id = 0, 
	//noc[routerID].channelArray[1].id = 1, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_se(int routerID) {
	channel north, west, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [north, west, local, spare1, spare2, spare3],
	noc[routerID].temp = [north, west, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0, 0/**/, 0/**/, 1, 2],
	
	//noc[routerID].channelArray[0].id = 0, 
	//noc[routerID].channelArray[1].id = 3, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
	
}

//runs routing after initial setup (for testing)
process initialRoute(int routerID) {
	{=
	noc[routerID].channelArray[0].direction = route(peekFront(noc[routerID].channelArray[0].buff), routerID),
	noc[routerID].channelArray[1].direction = route(peekFront(noc[routerID].channelArray[1].buff), routerID),
	noc[routerID].channelArray[2].direction = route(peekFront(noc[routerID].channelArray[2].buff), routerID)
	=}
}


//Sets the new priority of buffer channelArray[i] and forwards the destination if the buffer was serviced ------------------------------------------------------------------
process setPriority(int i, int routerID) {
	if (noc[routerID].channelArray[i].serviced == true) {
		if (noc[routerID].channelArray[i].direction == -1){ tau }
		else if(noc[routerID].channelArray[i].direction == 4) {			//Send in the local direction
			{= 
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
			noc[routerID].thisActivity++
			=}			//flit delivered
		}
		else if (noc[routerID].channelArray[i].direction == 0) {			//Send in the north direction
			sendNorth(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 1) {			//Send in the east direction
			sendEast(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 2) {			//Send in the south direction
			sendSouth(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 3) {			//Send in the west direction
			sendWest(routerID, noc[routerID].channelArray[i].buff);
			{= 
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else { tau };
		
		{=																								
		noc[routerID].channelArray[i].direction = -1,								
		noc[routerID].channelArray[i].priority = i + noc[routerID].unserviced 				//Set new priority                     
		=}
	}
	else {
		{= 
		noc[routerID].channelArray[i].priority = noc[routerID].totalUnserviced - noc[routerID].unserviced,		//Set new priority
		noc[routerID].unserviced-- 						//decrement unserviced
		=}
	}
}

//Updates the destination from the buffer if the buffer was serviced
process updateDestination(int i , int routerID) {
	if (noc[routerID].channelArray[i].serviced == true) {
		{=
		noc[routerID].channelArray[i].direction = route(peekFront(noc[routerID].channelArray[i].buff), routerID)		//Update direction from buffer
		=}
	} else {
		tau
	}
}

process sendNorth(int routerID, intlist option source) {
	if (routerID == 2) {
		{=
		noc[0].channelArray[noc[0].nsPos].buff = enqueue(peekFront(source), noc[0].channelArray[noc[0].nsPos].buff)
		//,source = dequeue(source)
		=}
	}
	else if (routerID == 3) {
		{=
		noc[1].channelArray[noc[1].nsPos].buff = enqueue(peekFront(source), noc[1].channelArray[noc[1].nsPos].buff)
		//,source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendEast(int routerID, intlist option source) {
	if (routerID == 0) {
		{=
		noc[1].channelArray[noc[1].ewPos].buff = enqueue(peekFront(source), noc[1].channelArray[noc[1].ewPos].buff)
		//,source = dequeue(source)
		=}
	} else if(routerID == 2) {
		{=
		noc[3].channelArray[noc[3].ewPos].buff = enqueue(peekFront(source), noc[3].channelArray[noc[3].ewPos].buff)
		//,source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendSouth(int routerID, intlist option source) {
	if (routerID == 0) {
		{=
		noc[2].channelArray[noc[2].nsPos].buff = enqueue(peekFront(source), noc[2].channelArray[noc[2].nsPos].buff),
		source = dequeue(source)
		=}
	} else if(routerID == 1) {
		{=
		noc[3].channelArray[noc[3].nsPos].buff = enqueue(peekFront(source), noc[3].channelArray[noc[3].nsPos].buff),
		source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendWest(int routerID, intlist option source) {
	if (routerID == 1) {
		{=
		noc[0].channelArray[noc[0].ewPos].buff = enqueue(peekFront(source), noc[0].channelArray[noc[0].ewPos].buff),
		source = dequeue(source)
		=}
	} else if (routerID == 3) {
		{=
		noc[2].channelArray[noc[2].ewPos].buff = enqueue(peekFront(source), noc[2].channelArray[noc[2].ewPos].buff),
		source = dequeue(source)
		=}
	} else {
		tau
	}
}

// ------- End: process definitions -------
par {
::	Clock()
:: 	Top()
}

property R_400 = Pmax(<>[S(clk)<=400] (resistiveNoise >= RESISTIVE_THRESH));
property R_401 = Pmax(<>[S(clk)<=401] (resistiveNoise >= RESISTIVE_THRESH));
property R_402 = Pmax(<>[S(clk)<=402] (resistiveNoise >= RESISTIVE_THRESH));
property R_403 = Pmax(<>[S(clk)<=403] (resistiveNoise >= RESISTIVE_THRESH));
property R_404 = Pmax(<>[S(clk)<=404] (resistiveNoise >= RESISTIVE_THRESH));
property R_405 = Pmax(<>[S(clk)<=405] (resistiveNoise >= RESISTIVE_THRESH));
property R_406 = Pmax(<>[S(clk)<=406] (resistiveNoise >= RESISTIVE_THRESH));
property R_407 = Pmax(<>[S(clk)<=407] (resistiveNoise >= RESISTIVE_THRESH));
property R_408 = Pmax(<>[S(clk)<=408] (resistiveNoise >= RESISTIVE_THRESH));
property R_409 = Pmax(<>[S(clk)<=409] (resistiveNoise >= RESISTIVE_THRESH));
property R_410 = Pmax(<>[S(clk)<=410] (resistiveNoise >= RESISTIVE_THRESH));
property R_411 = Pmax(<>[S(clk)<=411] (resistiveNoise >= RESISTIVE_THRESH));
property R_412 = Pmax(<>[S(clk)<=412] (resistiveNoise >= RESISTIVE_THRESH));
property R_413 = Pmax(<>[S(clk)<=413] (resistiveNoise >= RESISTIVE_THRESH));
property R_414 = Pmax(<>[S(clk)<=414] (resistiveNoise >= RESISTIVE_THRESH));
property R_415 = Pmax(<>[S(clk)<=415] (resistiveNoise >= RESISTIVE_THRESH));
property R_416 = Pmax(<>[S(clk)<=416] (resistiveNoise >= RESISTIVE_THRESH));
property R_417 = Pmax(<>[S(clk)<=417] (resistiveNoise >= RESISTIVE_THRESH));
property R_418 = Pmax(<>[S(clk)<=418] (resistiveNoise >= RESISTIVE_THRESH));
property R_419 = Pmax(<>[S(clk)<=419] (resistiveNoise >= RESISTIVE_THRESH));
property R_420 = Pmax(<>[S(clk)<=420] (resistiveNoise >= RESISTIVE_THRESH));
property R_421 = Pmax(<>[S(clk)<=421] (resistiveNoise >= RESISTIVE_THRESH));
property R_422 = Pmax(<>[S(clk)<=422] (resistiveNoise >= RESISTIVE_THRESH));
property R_423 = Pmax(<>[S(clk)<=423] (resistiveNoise >= RESISTIVE_THRESH));
property R_424 = Pmax(<>[S(clk)<=424] (resistiveNoise >= RESISTIVE_THRESH));
property R_425 = Pmax(<>[S(clk)<=425] (resistiveNoise >= RESISTIVE_THRESH));
property R_426 = Pmax(<>[S(clk)<=426] (resistiveNoise >= RESISTIVE_THRESH));
property R_427 = Pmax(<>[S(clk)<=427] (resistiveNoise >= RESISTIVE_THRESH));
property R_428 = Pmax(<>[S(clk)<=428] (resistiveNoise >= RESISTIVE_THRESH));
property R_429 = Pmax(<>[S(clk)<=429] (resistiveNoise >= RESISTIVE_THRESH));
property R_430 = Pmax(<>[S(clk)<=430] (resistiveNoise >= RESISTIVE_THRESH));
property R_431 = Pmax(<>[S(clk)<=431] (resistiveNoise >= RESISTIVE_THRESH));
property R_432 = Pmax(<>[S(clk)<=432] (resistiveNoise >= RESISTIVE_THRESH));
property R_433 = Pmax(<>[S(clk)<=433] (resistiveNoise >= RESISTIVE_THRESH));
property R_434 = Pmax(<>[S(clk)<=434] (resistiveNoise >= RESISTIVE_THRESH));
property R_435 = Pmax(<>[S(clk)<=435] (resistiveNoise >= RESISTIVE_THRESH));
property R_436 = Pmax(<>[S(clk)<=436] (resistiveNoise >= RESISTIVE_THRESH));
property R_437 = Pmax(<>[S(clk)<=437] (resistiveNoise >= RESISTIVE_THRESH));
property R_438 = Pmax(<>[S(clk)<=438] (resistiveNoise >= RESISTIVE_THRESH));
property R_439 = Pmax(<>[S(clk)<=439] (resistiveNoise >= RESISTIVE_THRESH));
property R_440 = Pmax(<>[S(clk)<=440] (resistiveNoise >= RESISTIVE_THRESH));
property R_441 = Pmax(<>[S(clk)<=441] (resistiveNoise >= RESISTIVE_THRESH));
property R_442 = Pmax(<>[S(clk)<=442] (resistiveNoise >= RESISTIVE_THRESH));
property R_443 = Pmax(<>[S(clk)<=443] (resistiveNoise >= RESISTIVE_THRESH));
property R_444 = Pmax(<>[S(clk)<=444] (resistiveNoise >= RESISTIVE_THRESH));
property R_445 = Pmax(<>[S(clk)<=445] (resistiveNoise >= RESISTIVE_THRESH));
property R_446 = Pmax(<>[S(clk)<=446] (resistiveNoise >= RESISTIVE_THRESH));
property R_447 = Pmax(<>[S(clk)<=447] (resistiveNoise >= RESISTIVE_THRESH));
property R_448 = Pmax(<>[S(clk)<=448] (resistiveNoise >= RESISTIVE_THRESH));
property R_449 = Pmax(<>[S(clk)<=449] (resistiveNoise >= RESISTIVE_THRESH));
property R_450 = Pmax(<>[S(clk)<=450] (resistiveNoise >= RESISTIVE_THRESH));
property R_451 = Pmax(<>[S(clk)<=451] (resistiveNoise >= RESISTIVE_THRESH));
property R_452 = Pmax(<>[S(clk)<=452] (resistiveNoise >= RESISTIVE_THRESH));
property R_453 = Pmax(<>[S(clk)<=453] (resistiveNoise >= RESISTIVE_THRESH));
property R_454 = Pmax(<>[S(clk)<=454] (resistiveNoise >= RESISTIVE_THRESH));
property R_455 = Pmax(<>[S(clk)<=455] (resistiveNoise >= RESISTIVE_THRESH));
property R_456 = Pmax(<>[S(clk)<=456] (resistiveNoise >= RESISTIVE_THRESH));
property R_457 = Pmax(<>[S(clk)<=457] (resistiveNoise >= RESISTIVE_THRESH));
property R_458 = Pmax(<>[S(clk)<=458] (resistiveNoise >= RESISTIVE_THRESH));
property R_459 = Pmax(<>[S(clk)<=459] (resistiveNoise >= RESISTIVE_THRESH));
property R_460 = Pmax(<>[S(clk)<=460] (resistiveNoise >= RESISTIVE_THRESH));
property R_461 = Pmax(<>[S(clk)<=461] (resistiveNoise >= RESISTIVE_THRESH));
property R_462 = Pmax(<>[S(clk)<=462] (resistiveNoise >= RESISTIVE_THRESH));
property R_463 = Pmax(<>[S(clk)<=463] (resistiveNoise >= RESISTIVE_THRESH));
property R_464 = Pmax(<>[S(clk)<=464] (resistiveNoise >= RESISTIVE_THRESH));
property R_465 = Pmax(<>[S(clk)<=465] (resistiveNoise >= RESISTIVE_THRESH));
property R_466 = Pmax(<>[S(clk)<=466] (resistiveNoise >= RESISTIVE_THRESH));
property R_467 = Pmax(<>[S(clk)<=467] (resistiveNoise >= RESISTIVE_THRESH));
property R_468 = Pmax(<>[S(clk)<=468] (resistiveNoise >= RESISTIVE_THRESH));
property R_469 = Pmax(<>[S(clk)<=469] (resistiveNoise >= RESISTIVE_THRESH));
property R_470 = Pmax(<>[S(clk)<=470] (resistiveNoise >= RESISTIVE_THRESH));
property R_471 = Pmax(<>[S(clk)<=471] (resistiveNoise >= RESISTIVE_THRESH));
property R_472 = Pmax(<>[S(clk)<=472] (resistiveNoise >= RESISTIVE_THRESH));
property R_473 = Pmax(<>[S(clk)<=473] (resistiveNoise >= RESISTIVE_THRESH));
property R_474 = Pmax(<>[S(clk)<=474] (resistiveNoise >= RESISTIVE_THRESH));
property R_475 = Pmax(<>[S(clk)<=475] (resistiveNoise >= RESISTIVE_THRESH));
property R_476 = Pmax(<>[S(clk)<=476] (resistiveNoise >= RESISTIVE_THRESH));
property R_477 = Pmax(<>[S(clk)<=477] (resistiveNoise >= RESISTIVE_THRESH));
property R_478 = Pmax(<>[S(clk)<=478] (resistiveNoise >= RESISTIVE_THRESH));
property R_479 = Pmax(<>[S(clk)<=479] (resistiveNoise >= RESISTIVE_THRESH));
property R_480 = Pmax(<>[S(clk)<=480] (resistiveNoise >= RESISTIVE_THRESH));
property R_481 = Pmax(<>[S(clk)<=481] (resistiveNoise >= RESISTIVE_THRESH));
property R_482 = Pmax(<>[S(clk)<=482] (resistiveNoise >= RESISTIVE_THRESH));
property R_483 = Pmax(<>[S(clk)<=483] (resistiveNoise >= RESISTIVE_THRESH));
property R_484 = Pmax(<>[S(clk)<=484] (resistiveNoise >= RESISTIVE_THRESH));
property R_485 = Pmax(<>[S(clk)<=485] (resistiveNoise >= RESISTIVE_THRESH));
property R_486 = Pmax(<>[S(clk)<=486] (resistiveNoise >= RESISTIVE_THRESH));
property R_487 = Pmax(<>[S(clk)<=487] (resistiveNoise >= RESISTIVE_THRESH));
property R_488 = Pmax(<>[S(clk)<=488] (resistiveNoise >= RESISTIVE_THRESH));
property R_489 = Pmax(<>[S(clk)<=489] (resistiveNoise >= RESISTIVE_THRESH));
property R_490 = Pmax(<>[S(clk)<=490] (resistiveNoise >= RESISTIVE_THRESH));
property R_491 = Pmax(<>[S(clk)<=491] (resistiveNoise >= RESISTIVE_THRESH));
property R_492 = Pmax(<>[S(clk)<=492] (resistiveNoise >= RESISTIVE_THRESH));
property R_493 = Pmax(<>[S(clk)<=493] (resistiveNoise >= RESISTIVE_THRESH));
property R_494 = Pmax(<>[S(clk)<=494] (resistiveNoise >= RESISTIVE_THRESH));
property R_495 = Pmax(<>[S(clk)<=495] (resistiveNoise >= RESISTIVE_THRESH));
property R_496 = Pmax(<>[S(clk)<=496] (resistiveNoise >= RESISTIVE_THRESH));
property R_497 = Pmax(<>[S(clk)<=497] (resistiveNoise >= RESISTIVE_THRESH));
property R_498 = Pmax(<>[S(clk)<=498] (resistiveNoise >= RESISTIVE_THRESH));
property R_499 = Pmax(<>[S(clk)<=499] (resistiveNoise >= RESISTIVE_THRESH));