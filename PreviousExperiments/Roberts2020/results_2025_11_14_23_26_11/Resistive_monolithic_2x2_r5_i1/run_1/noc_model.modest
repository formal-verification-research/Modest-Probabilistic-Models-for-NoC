/* 
Monolithic NoC model
Author:
  Riley Roberts
  Jonah Boe
  Nick Waddoups

Edit history:
  Nick Waddoups, 2025: Setup file to regenerate reproducible results
*/
/*
NoC router IDs
	0 - 1
	|   |
	2 - 3
*/

option "dtmc";

//Top level varables
const int BUFFERLENGTH = 3; //Each buffer actually has length of BUFFERLENGTH + 1 because one directionue is stored in the arbiter itself for easy use when routing.
const int NOCSIZE = 2;
const int INJECTIONRATENUMERATOR = 3;
const int INJECTIONRATEDENOMINATOR = 10;

const int ACTIVITY_THRESH = 3;
const int RESISTIVE_THRESH;
const int INDUCTIVE_THRESH;

transient int(0..1) clk;
int(0..INJECTIONRATEDENOMINATOR-1) clk_counter = 0;

datatype intlist = {
	int(0..((NOCSIZE*NOCSIZE)-1)) hd,
	intlist option tl
};

// Datatype for a channel with the next buffer directionue, id of the buffer,
// whether the buffer was serviced last clock cycle or not, and the priority
// number of the buffer
datatype channel = {
	int(-1..4) direction,
	bool serviced,
	int(0..2) priority,
	intlist option buff
};

// Datatype for a router, includes router-specific variables and an array of buffers
datatype router = {
	int(0..3) unserviced,
	int(0..3) totalUnserviced,
	int(0..3) thisActivity,
	int(0..3) lastActivity,
	channel[] channelArray,
	channel[] temp,
	int(0..2) localPos,
	int(0..2) nsPos,
	int(0..2) ewPos /*int[] bufferID*/
};

// Noise counters 
int(0..) resistiveNoise = 0;
int(0..) inductiveNoise = 0;

router[] noc = [
	router {unserviced:0},
	router {unserviced:0},
	router {unserviced:0},
	router {unserviced:0}
];

action tick;

// ------ Begin: function definitions ------- 
// Calculate length of list:
// "!" accesses the value of a non-empty option (causes an error if the option is empty)
function int len(intlist option ls) =
	if ls == none 
	then 0 
	else 1 + len(ls!.tl); 

// Return the front of the queue, i.e., the last element of the given integer list.
// No changes are made to the list.
function int peekFront(intlist option ls) =
	if ls == none then -1
	else if ls!.tl == none then ls!.hd
	else peekFront(ls!.tl);

//Remove the front of the queue, i.e., the last element of the given integer list.
// Return the modified list.
function intlist option dequeue(intlist option ls) = 
	if ls == none then none
	else if	ls!.tl == none then none 
	else some(intlist { hd: ls!.hd, tl: dequeue(ls!.tl) });																		// Remove the last item from the tail

//Insert a new entry n as the head of the list ls. If ls has already reached its
// capacity before adding n, return ls; otherwise, return modified ls with n as
// its head. 
function intlist option enqueue(int n, intlist option ls) = 
	if len(ls) == BUFFERLENGTH then ls
	else some(intlist { hd: n, tl: ls });		 

//Routing function	(x-y routing)
function int route(int dest, int routerID) =
	if dest == -1 then -1//no flit
	else if (dest == routerID) then 4//local
	else if (dest % NOCSIZE) > (routerID % NOCSIZE) then 1/*east*/
	else if (dest % NOCSIZE) < (routerID % NOCSIZE) then 3/*west*/
	else if (dest / NOCSIZE) > (routerID / NOCSIZE) then 2/*south*/
	else if (dest / NOCSIZE) < (routerID / NOCSIZE) then 0/*north*/
	else 4//local
	;

function bool checkNotFull(int direction, int routerID) = 																		// Check if input buffer of input NoC is full
	if direction == -1 then true //no flit
	else if (direction == 0 && routerID - NOCSIZE >= 0) 
		then len(noc[routerID - NOCSIZE].channelArray[noc[routerID - NOCSIZE].nsPos].buff) < BUFFERLENGTH
	else if (direction == 1  && routerID + 1 <= 3) 
		then len(noc[routerID + 1].channelArray[noc[routerID + 1].ewPos].buff) < BUFFERLENGTH
	else if (direction == 2  && routerID + NOCSIZE <= 3) 
		then len(noc[routerID + NOCSIZE].channelArray[noc[routerID + NOCSIZE].nsPos].buff) < BUFFERLENGTH
	else if (direction == 3  && routerID - 1 >= 0) 
		then len(noc[routerID - 1].channelArray[noc[routerID - 1].ewPos].buff) < BUFFERLENGTH
	else if direction == 4 
		then true //send local
	else false //catch all case
	;
	
function int(0..1) checkNotFullIncrement(int direction, int routerID) = 
	(checkNotFull(direction, routerID)) ? 0 : 1;			// CheckNotFull, but returning int 0 or 1

// ------ Begin: process definitions ------
//---- Parallel Processes ----
process Clock() {	
	tick {= clk = 1, clk_counter = (clk_counter + 1) % INJECTIONRATEDENOMINATOR =};
	Clock()
}

process Top() {
	initialize();
	Populate();
	initialRoute(0);
	initialRoute(1);
	initialRoute(2);
	initialRoute(3);
	do {
		Arbiter_corner(0);																										// Resolve shifting the input buffers by one
		Arbiter_corner(1);
		Arbiter_corner(2);
		Arbiter_corner(3);	
		
		Measure_noise(0);
		Measure_noise(1);
		Measure_noise(2);
		Measure_noise(3);

		tick;
		
		Populate();																												// Populate new flits
		
		updateDestination(0, 0);																								// Update where the flits that have been serviced now
		updateDestination(1, 0);																								// need to go
		updateDestination(2, 0);
		
		updateDestination(0, 1);
		updateDestination(1, 1);
		updateDestination(2, 1);
		
		updateDestination(0, 2);
		updateDestination(1, 2);
		updateDestination(2, 2);
		
		updateDestination(0, 3);
		updateDestination(1, 3);
		updateDestination(2, 3)
	}
}

process Populate() {
	if ((clk_counter % INJECTIONRATEDENOMINATOR) < INJECTIONRATENUMERATOR){																// Flit injection happens every n/d clk cycles
		palt {
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(1, noc[0].channelArray[noc[0].localPos].buff) =}		// A new flit produced by noc 0 has a 1 in 3 chanc of
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(2, noc[0].channelArray[noc[0].localPos].buff) =}		// any of the other 3 oncs being its endpoint
			:(1/3): {= noc[0].channelArray[noc[0].localPos].buff = enqueue(3, noc[0].channelArray[noc[0].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(0, noc[1].channelArray[noc[1].localPos].buff) =}
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(2, noc[1].channelArray[noc[1].localPos].buff) =}
			:(1/3): {= noc[1].channelArray[noc[1].localPos].buff = enqueue(3, noc[1].channelArray[noc[1].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(0, noc[2].channelArray[noc[2].localPos].buff) =}
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(1, noc[2].channelArray[noc[2].localPos].buff) =}
			:(1/3): {= noc[2].channelArray[noc[2].localPos].buff = enqueue(3, noc[2].channelArray[noc[2].localPos].buff) =}
		};
		palt {
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(0, noc[3].channelArray[noc[3].localPos].buff) =}
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(1, noc[3].channelArray[noc[3].localPos].buff) =}
			:(1/3): {= noc[3].channelArray[noc[3].localPos].buff = enqueue(2, noc[3].channelArray[noc[3].localPos].buff) =}
		}
	} else {
		tau
	}
}


//---- Sub processes ----
process Arbiter_corner(int routerID) {
	//Service buffers-------------------------------------------------------------------------------------------------------
		
		//Buffer priority 0
		//<Service Buffer channelArray[0]>--------------------------------------------------------
		{=
		noc[routerID].channelArray[0].serviced = checkNotFull(noc[routerID].channelArray[0].direction, routerID),				// If buffer between ID and direction is not full...
		noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[0].direction, routerID),				// add one more to the buffer if a new flit has been
		noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[0].direction, routerID)					// generated in that direction
		=};
		
		//<Service buffer channelArray[1]> ------------------------------------------------------
		if (noc[routerID].channelArray[1].direction == -1 || noc[routerID].channelArray[1].direction != noc[routerID].channelArray[0].direction) {			//If buffer channelArray[1] does not conflict with channelArray[0]
			{= 	//Service Buffer
			noc[routerID].channelArray[1].serviced = checkNotFull(noc[routerID].channelArray[1].direction, routerID),
			noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[1].direction, routerID),
			noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[1].direction, routerID)
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[1].serviced = false,
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++ 		//Increment unserviced
			=}
		};
		
		//<Service buffer channelArray[2]> --------------------------------------------------------
		//If buffer channelArray[2] does not conflict with channelArray[1] or channelArray[0]
		if (noc[routerID].channelArray[2].direction == -1 || noc[routerID].channelArray[2].direction != noc[routerID].channelArray[1].direction && noc[routerID].channelArray[2].direction != noc[routerID].channelArray[0].direction){	
			{= 	//Service Buffer
			noc[routerID].channelArray[2].serviced = checkNotFull(noc[routerID].channelArray[2].direction, routerID),
			noc[routerID].totalUnserviced += checkNotFullIncrement(noc[routerID].channelArray[2].direction, routerID),
			noc[routerID].unserviced += checkNotFullIncrement(noc[routerID].channelArray[2].direction, routerID)
			=}
		}
		else {
			{= 
			noc[routerID].channelArray[2].serviced = false, 
			noc[routerID].totalUnserviced++,
			noc[routerID].unserviced++			//Increment unserviced
			=}
		};
	
		//Set priority directions for the next run and update the direction of the buffers----------------------------------------------
		setPriority(0, routerID);
		setPriority(1, routerID);
		setPriority(2, routerID);
		
		// need to update the bufferID array
		// test update for router 0
		{=
			noc[routerID].ewPos = noc[routerID].channelArray[noc[routerID].ewPos].priority,
			noc[routerID].nsPos = noc[routerID].channelArray[noc[routerID].nsPos].priority,
			noc[routerID].localPos = noc[routerID].channelArray[noc[routerID].localPos].priority,
			
			noc[routerID].totalUnserviced = 0			//reset Total Unserviced to 0 for next cycle
		=};
		
		//Rewrite buffer array with new priority values-------------------------------------------------------------------------
		{= 
		noc[routerID].temp[noc[routerID].channelArray[0].priority] = noc[routerID].channelArray[0],
		noc[routerID].temp[noc[routerID].channelArray[1].priority] = noc[routerID].channelArray[1],
		noc[routerID].temp[noc[routerID].channelArray[2].priority] = noc[routerID].channelArray[2]//,
		
		//noc[routerID].bufferID[noc[routerID].channelArray[0].id] = noc[routerID].channelArray[0].priority,
		//noc[routerID].bufferID[noc[routerID].channelArray[1].id] = noc[routerID].channelArray[1].priority,
		//noc[routerID].bufferID[noc[routerID].channelArray[2].id] = noc[routerID].channelArray[2].priority
		=};
		
		{= noc[routerID].channelArray = noc[routerID].temp =}
}
	
// Measure PSN
process Measure_noise(int routerID)
{
	{=
		0: resistiveNoise = noc[routerID].thisActivity >= ACTIVITY_THRESH
			? resistiveNoise + 1
			: resistiveNoise,
		0: inductiveNoise = abs(noc[routerID].lastActivity - noc[routerID].thisActivity) >= ACTIVITY_THRESH
			? inductiveNoise + 1
			: inductiveNoise,
		
		1: noc[routerID].lastActivity = noc[routerID].thisActivity,
		1: noc[routerID].thisActivity = 0
	=}
}

//initialize values --------------------------------------------------------------------------------------------------------------------------------------------
process initialize() {
	initialize_node_nw(0);
	initialize_node_ne(1);
	initialize_node_sw(2);
	initialize_node_se(3)
}

process initialize_node_nw(int routerID) {
	channel east, south, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [east, south, local, spare1, spare2, spare3],
	noc[routerID].temp = [east, south, local, spare1, spare2, spare3],
	
	noc[routerID].ewPos = 0,
	noc[routerID].nsPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0/**/, 0, 1, 0/**/, 2],
	
	//noc[routerID].channelArray[0].id = 1, 
	//noc[routerID].channelArray[1].id = 2, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_ne(int routerID) {
	channel south, west, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [south, west, local, spare1, spare2, spare3],
	noc[routerID].temp = [south, west, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0/**/, 0/**/, 0, 1, 2],
	
	//noc[routerID].channelArray[0].id = 2, 
	//noc[routerID].channelArray[1].id = 3, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_sw(int routerID) {
	channel north, east, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [north, east, local, spare1, spare2, spare3],
	noc[routerID].temp = [north, east, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0, 1, 0/**/, 0/**/, 2],
	
	//noc[routerID].channelArray[0].id = 0, 
	//noc[routerID].channelArray[1].id = 1, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
}

process initialize_node_se(int routerID) {
	channel north, west, local, spare1, spare2, spare3;
	{=
	noc[routerID].channelArray = [north, west, local, spare1, spare2, spare3],
	noc[routerID].temp = [north, west, local, spare1, spare2, spare3], 
	
	noc[routerID].nsPos = 0,
	noc[routerID].ewPos = 1,
	noc[routerID].localPos = 2,
	
	//noc[routerID].bufferID = [0, 0/**/, 0/**/, 1, 2],
	
	//noc[routerID].channelArray[0].id = 0, 
	//noc[routerID].channelArray[1].id = 3, 
	//noc[routerID].channelArray[2].id = 4,
	
	noc[routerID].unserviced = 0,
	noc[routerID].thisActivity = 0,
	noc[routerID].lastActivity = 0
	=}
	
}

//runs routing after initial setup (for testing)
process initialRoute(int routerID) {
	{=
	noc[routerID].channelArray[0].direction = route(peekFront(noc[routerID].channelArray[0].buff), routerID),
	noc[routerID].channelArray[1].direction = route(peekFront(noc[routerID].channelArray[1].buff), routerID),
	noc[routerID].channelArray[2].direction = route(peekFront(noc[routerID].channelArray[2].buff), routerID)
	=}
}


//Sets the new priority of buffer channelArray[i] and forwards the destination if the buffer was serviced ------------------------------------------------------------------
process setPriority(int i, int routerID) {
	if (noc[routerID].channelArray[i].serviced == true) {
		if (noc[routerID].channelArray[i].direction == -1){ tau }
		else if(noc[routerID].channelArray[i].direction == 4) {			//Send in the local direction
			{= 
			noc[routerID].channelArray[i].direction = -1,
			noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
			noc[routerID].thisActivity++
			=}			//flit delivered
		}
		else if (noc[routerID].channelArray[i].direction == 0) {			//Send in the north direction
			sendNorth(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 1) {			//Send in the east direction
			sendEast(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 2) {			//Send in the south direction
			sendSouth(routerID, noc[routerID].channelArray[i].buff);
			{=
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else if (noc[routerID].channelArray[i].direction == 3) {			//Send in the west direction
			sendWest(routerID, noc[routerID].channelArray[i].buff);
			{= 
				noc[routerID].channelArray[i].buff = dequeue(noc[routerID].channelArray[i].buff),
				noc[routerID].thisActivity++
			=}
		}
		else { tau };
		
		{=																								
		noc[routerID].channelArray[i].direction = -1,								
		noc[routerID].channelArray[i].priority = i + noc[routerID].unserviced 				//Set new priority                     
		=}
	}
	else {
		{= 
		noc[routerID].channelArray[i].priority = noc[routerID].totalUnserviced - noc[routerID].unserviced,		//Set new priority
		noc[routerID].unserviced-- 						//decrement unserviced
		=}
	}
}

//Updates the destination from the buffer if the buffer was serviced
process updateDestination(int i , int routerID) {
	if (noc[routerID].channelArray[i].serviced == true) {
		{=
		noc[routerID].channelArray[i].direction = route(peekFront(noc[routerID].channelArray[i].buff), routerID)		//Update direction from buffer
		=}
	} else {
		tau
	}
}

process sendNorth(int routerID, intlist option source) {
	if (routerID == 2) {
		{=
		noc[0].channelArray[noc[0].nsPos].buff = enqueue(peekFront(source), noc[0].channelArray[noc[0].nsPos].buff)
		//,source = dequeue(source)
		=}
	}
	else if (routerID == 3) {
		{=
		noc[1].channelArray[noc[1].nsPos].buff = enqueue(peekFront(source), noc[1].channelArray[noc[1].nsPos].buff)
		//,source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendEast(int routerID, intlist option source) {
	if (routerID == 0) {
		{=
		noc[1].channelArray[noc[1].ewPos].buff = enqueue(peekFront(source), noc[1].channelArray[noc[1].ewPos].buff)
		//,source = dequeue(source)
		=}
	} else if(routerID == 2) {
		{=
		noc[3].channelArray[noc[3].ewPos].buff = enqueue(peekFront(source), noc[3].channelArray[noc[3].ewPos].buff)
		//,source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendSouth(int routerID, intlist option source) {
	if (routerID == 0) {
		{=
		noc[2].channelArray[noc[2].nsPos].buff = enqueue(peekFront(source), noc[2].channelArray[noc[2].nsPos].buff),
		source = dequeue(source)
		=}
	} else if(routerID == 1) {
		{=
		noc[3].channelArray[noc[3].nsPos].buff = enqueue(peekFront(source), noc[3].channelArray[noc[3].nsPos].buff),
		source = dequeue(source)
		=}
	} else {
		tau
	}
}

process sendWest(int routerID, intlist option source) {
	if (routerID == 1) {
		{=
		noc[0].channelArray[noc[0].ewPos].buff = enqueue(peekFront(source), noc[0].channelArray[noc[0].ewPos].buff),
		source = dequeue(source)
		=}
	} else if (routerID == 3) {
		{=
		noc[2].channelArray[noc[2].ewPos].buff = enqueue(peekFront(source), noc[2].channelArray[noc[2].ewPos].buff),
		source = dequeue(source)
		=}
	} else {
		tau
	}
}

// ------- End: process definitions -------
par {
::	Clock()
:: 	Top()
}

property R_100 = Pmax(<>[S(clk)<=100] (resistiveNoise >= RESISTIVE_THRESH));
property R_101 = Pmax(<>[S(clk)<=101] (resistiveNoise >= RESISTIVE_THRESH));
property R_102 = Pmax(<>[S(clk)<=102] (resistiveNoise >= RESISTIVE_THRESH));
property R_103 = Pmax(<>[S(clk)<=103] (resistiveNoise >= RESISTIVE_THRESH));
property R_104 = Pmax(<>[S(clk)<=104] (resistiveNoise >= RESISTIVE_THRESH));
property R_105 = Pmax(<>[S(clk)<=105] (resistiveNoise >= RESISTIVE_THRESH));
property R_106 = Pmax(<>[S(clk)<=106] (resistiveNoise >= RESISTIVE_THRESH));
property R_107 = Pmax(<>[S(clk)<=107] (resistiveNoise >= RESISTIVE_THRESH));
property R_108 = Pmax(<>[S(clk)<=108] (resistiveNoise >= RESISTIVE_THRESH));
property R_109 = Pmax(<>[S(clk)<=109] (resistiveNoise >= RESISTIVE_THRESH));
property R_110 = Pmax(<>[S(clk)<=110] (resistiveNoise >= RESISTIVE_THRESH));
property R_111 = Pmax(<>[S(clk)<=111] (resistiveNoise >= RESISTIVE_THRESH));
property R_112 = Pmax(<>[S(clk)<=112] (resistiveNoise >= RESISTIVE_THRESH));
property R_113 = Pmax(<>[S(clk)<=113] (resistiveNoise >= RESISTIVE_THRESH));
property R_114 = Pmax(<>[S(clk)<=114] (resistiveNoise >= RESISTIVE_THRESH));
property R_115 = Pmax(<>[S(clk)<=115] (resistiveNoise >= RESISTIVE_THRESH));
property R_116 = Pmax(<>[S(clk)<=116] (resistiveNoise >= RESISTIVE_THRESH));
property R_117 = Pmax(<>[S(clk)<=117] (resistiveNoise >= RESISTIVE_THRESH));
property R_118 = Pmax(<>[S(clk)<=118] (resistiveNoise >= RESISTIVE_THRESH));
property R_119 = Pmax(<>[S(clk)<=119] (resistiveNoise >= RESISTIVE_THRESH));
property R_120 = Pmax(<>[S(clk)<=120] (resistiveNoise >= RESISTIVE_THRESH));
property R_121 = Pmax(<>[S(clk)<=121] (resistiveNoise >= RESISTIVE_THRESH));
property R_122 = Pmax(<>[S(clk)<=122] (resistiveNoise >= RESISTIVE_THRESH));
property R_123 = Pmax(<>[S(clk)<=123] (resistiveNoise >= RESISTIVE_THRESH));
property R_124 = Pmax(<>[S(clk)<=124] (resistiveNoise >= RESISTIVE_THRESH));
property R_125 = Pmax(<>[S(clk)<=125] (resistiveNoise >= RESISTIVE_THRESH));
property R_126 = Pmax(<>[S(clk)<=126] (resistiveNoise >= RESISTIVE_THRESH));
property R_127 = Pmax(<>[S(clk)<=127] (resistiveNoise >= RESISTIVE_THRESH));
property R_128 = Pmax(<>[S(clk)<=128] (resistiveNoise >= RESISTIVE_THRESH));
property R_129 = Pmax(<>[S(clk)<=129] (resistiveNoise >= RESISTIVE_THRESH));
property R_130 = Pmax(<>[S(clk)<=130] (resistiveNoise >= RESISTIVE_THRESH));
property R_131 = Pmax(<>[S(clk)<=131] (resistiveNoise >= RESISTIVE_THRESH));
property R_132 = Pmax(<>[S(clk)<=132] (resistiveNoise >= RESISTIVE_THRESH));
property R_133 = Pmax(<>[S(clk)<=133] (resistiveNoise >= RESISTIVE_THRESH));
property R_134 = Pmax(<>[S(clk)<=134] (resistiveNoise >= RESISTIVE_THRESH));
property R_135 = Pmax(<>[S(clk)<=135] (resistiveNoise >= RESISTIVE_THRESH));
property R_136 = Pmax(<>[S(clk)<=136] (resistiveNoise >= RESISTIVE_THRESH));
property R_137 = Pmax(<>[S(clk)<=137] (resistiveNoise >= RESISTIVE_THRESH));
property R_138 = Pmax(<>[S(clk)<=138] (resistiveNoise >= RESISTIVE_THRESH));
property R_139 = Pmax(<>[S(clk)<=139] (resistiveNoise >= RESISTIVE_THRESH));
property R_140 = Pmax(<>[S(clk)<=140] (resistiveNoise >= RESISTIVE_THRESH));
property R_141 = Pmax(<>[S(clk)<=141] (resistiveNoise >= RESISTIVE_THRESH));
property R_142 = Pmax(<>[S(clk)<=142] (resistiveNoise >= RESISTIVE_THRESH));
property R_143 = Pmax(<>[S(clk)<=143] (resistiveNoise >= RESISTIVE_THRESH));
property R_144 = Pmax(<>[S(clk)<=144] (resistiveNoise >= RESISTIVE_THRESH));
property R_145 = Pmax(<>[S(clk)<=145] (resistiveNoise >= RESISTIVE_THRESH));
property R_146 = Pmax(<>[S(clk)<=146] (resistiveNoise >= RESISTIVE_THRESH));
property R_147 = Pmax(<>[S(clk)<=147] (resistiveNoise >= RESISTIVE_THRESH));
property R_148 = Pmax(<>[S(clk)<=148] (resistiveNoise >= RESISTIVE_THRESH));
property R_149 = Pmax(<>[S(clk)<=149] (resistiveNoise >= RESISTIVE_THRESH));
property R_150 = Pmax(<>[S(clk)<=150] (resistiveNoise >= RESISTIVE_THRESH));
property R_151 = Pmax(<>[S(clk)<=151] (resistiveNoise >= RESISTIVE_THRESH));
property R_152 = Pmax(<>[S(clk)<=152] (resistiveNoise >= RESISTIVE_THRESH));
property R_153 = Pmax(<>[S(clk)<=153] (resistiveNoise >= RESISTIVE_THRESH));
property R_154 = Pmax(<>[S(clk)<=154] (resistiveNoise >= RESISTIVE_THRESH));
property R_155 = Pmax(<>[S(clk)<=155] (resistiveNoise >= RESISTIVE_THRESH));
property R_156 = Pmax(<>[S(clk)<=156] (resistiveNoise >= RESISTIVE_THRESH));
property R_157 = Pmax(<>[S(clk)<=157] (resistiveNoise >= RESISTIVE_THRESH));
property R_158 = Pmax(<>[S(clk)<=158] (resistiveNoise >= RESISTIVE_THRESH));
property R_159 = Pmax(<>[S(clk)<=159] (resistiveNoise >= RESISTIVE_THRESH));
property R_160 = Pmax(<>[S(clk)<=160] (resistiveNoise >= RESISTIVE_THRESH));
property R_161 = Pmax(<>[S(clk)<=161] (resistiveNoise >= RESISTIVE_THRESH));
property R_162 = Pmax(<>[S(clk)<=162] (resistiveNoise >= RESISTIVE_THRESH));
property R_163 = Pmax(<>[S(clk)<=163] (resistiveNoise >= RESISTIVE_THRESH));
property R_164 = Pmax(<>[S(clk)<=164] (resistiveNoise >= RESISTIVE_THRESH));
property R_165 = Pmax(<>[S(clk)<=165] (resistiveNoise >= RESISTIVE_THRESH));
property R_166 = Pmax(<>[S(clk)<=166] (resistiveNoise >= RESISTIVE_THRESH));
property R_167 = Pmax(<>[S(clk)<=167] (resistiveNoise >= RESISTIVE_THRESH));
property R_168 = Pmax(<>[S(clk)<=168] (resistiveNoise >= RESISTIVE_THRESH));
property R_169 = Pmax(<>[S(clk)<=169] (resistiveNoise >= RESISTIVE_THRESH));
property R_170 = Pmax(<>[S(clk)<=170] (resistiveNoise >= RESISTIVE_THRESH));
property R_171 = Pmax(<>[S(clk)<=171] (resistiveNoise >= RESISTIVE_THRESH));
property R_172 = Pmax(<>[S(clk)<=172] (resistiveNoise >= RESISTIVE_THRESH));
property R_173 = Pmax(<>[S(clk)<=173] (resistiveNoise >= RESISTIVE_THRESH));
property R_174 = Pmax(<>[S(clk)<=174] (resistiveNoise >= RESISTIVE_THRESH));
property R_175 = Pmax(<>[S(clk)<=175] (resistiveNoise >= RESISTIVE_THRESH));
property R_176 = Pmax(<>[S(clk)<=176] (resistiveNoise >= RESISTIVE_THRESH));
property R_177 = Pmax(<>[S(clk)<=177] (resistiveNoise >= RESISTIVE_THRESH));
property R_178 = Pmax(<>[S(clk)<=178] (resistiveNoise >= RESISTIVE_THRESH));
property R_179 = Pmax(<>[S(clk)<=179] (resistiveNoise >= RESISTIVE_THRESH));
property R_180 = Pmax(<>[S(clk)<=180] (resistiveNoise >= RESISTIVE_THRESH));
property R_181 = Pmax(<>[S(clk)<=181] (resistiveNoise >= RESISTIVE_THRESH));
property R_182 = Pmax(<>[S(clk)<=182] (resistiveNoise >= RESISTIVE_THRESH));
property R_183 = Pmax(<>[S(clk)<=183] (resistiveNoise >= RESISTIVE_THRESH));
property R_184 = Pmax(<>[S(clk)<=184] (resistiveNoise >= RESISTIVE_THRESH));
property R_185 = Pmax(<>[S(clk)<=185] (resistiveNoise >= RESISTIVE_THRESH));
property R_186 = Pmax(<>[S(clk)<=186] (resistiveNoise >= RESISTIVE_THRESH));
property R_187 = Pmax(<>[S(clk)<=187] (resistiveNoise >= RESISTIVE_THRESH));
property R_188 = Pmax(<>[S(clk)<=188] (resistiveNoise >= RESISTIVE_THRESH));
property R_189 = Pmax(<>[S(clk)<=189] (resistiveNoise >= RESISTIVE_THRESH));
property R_190 = Pmax(<>[S(clk)<=190] (resistiveNoise >= RESISTIVE_THRESH));
property R_191 = Pmax(<>[S(clk)<=191] (resistiveNoise >= RESISTIVE_THRESH));
property R_192 = Pmax(<>[S(clk)<=192] (resistiveNoise >= RESISTIVE_THRESH));
property R_193 = Pmax(<>[S(clk)<=193] (resistiveNoise >= RESISTIVE_THRESH));
property R_194 = Pmax(<>[S(clk)<=194] (resistiveNoise >= RESISTIVE_THRESH));
property R_195 = Pmax(<>[S(clk)<=195] (resistiveNoise >= RESISTIVE_THRESH));
property R_196 = Pmax(<>[S(clk)<=196] (resistiveNoise >= RESISTIVE_THRESH));
property R_197 = Pmax(<>[S(clk)<=197] (resistiveNoise >= RESISTIVE_THRESH));
property R_198 = Pmax(<>[S(clk)<=198] (resistiveNoise >= RESISTIVE_THRESH));
property R_199 = Pmax(<>[S(clk)<=199] (resistiveNoise >= RESISTIVE_THRESH));