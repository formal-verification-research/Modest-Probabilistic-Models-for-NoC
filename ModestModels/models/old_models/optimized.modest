/***********
[info][section start] Section automatically generated by `type()` in 'noc.py'
***********/
option "dtmc";
/***********
[info][section end] Section automatically generated by `type()`
***********/

/***********
[info][section start] Section automatically generated by `variables()` in 'noc.py'
***********/
//----- VARIABLES -----

// #MODULARIZE by setting NOC_MAX_ID to 1 less than the total number of routers and allocating spaces for more routers
const int NOC_MAX_ID = 3;

// #CUSTOMIZE this value changes the buffer length of all buffers.
const int BUFFER_LENGTH = 4;

// #CUSTOMIZE the number of buffers a router must service before noise will be incramented.
const int ACTIVITY_THRESH = 3;

// #CUSTOMIZE these values change the frequency with witch flits are injected.
const int INJECTION_RATE_NUMERATOR = 3;
const int INJECTION_RATE_DENOMINATOR =10;

// #CUSTOMIZE this is the upper bound of cycles run before quiting.
int(0..INJECTION_RATE_DENOMINATOR) clk = 0;
transient int(0..1) clk_indicator;

// #CUSTOMIZE this is the upper threshoold for noise detected in the system.
const int RESISTIVE_NOISE_THRESH = 1;
const int INDUCTIVE_NOISE_THRESH = 1;

// These are for tracking resistive and inductive noise and must be initialized to 0.
int resistiveNoise = 0;
int inductiveNoise = 0;

// These values are enumerations and are NOT to be changed
const int NORTH = 0;
const int WEST = 1;
const int EAST = 2;
const int SOUTH = 3;
const int LOCAL = 4;
const int NO_CONNECT = -1;
/***********
[info][section end] Section automatically generated by `variables()`
***********/

/***********
[info][section start] Section automatically generated by `datatypes()` in 'noc.py'
***********/
datatype buffer = {
    int(0..NOC_MAX_ID) hd,
    buffer option tl
};

datatype channel = {
    buffer option buffer,
    bool serviced,
    bool isEmpty,
    bool isFull
};

datatype router = {
    channel[] channels,
    int(-1..NOC_MAX_ID)[] ids,
    int(0..4)[] priority_list,
    int(0..4)[] priority_list_temp,
    int(0..4) serviced_index,
    int(0..4) unserviced_index,
    int(0..5) total_unserviced,
    int(0..) thisActivity,
    int(0..) lastActivity,
    bool[] used
};

/***********
[info][section end] Section automatically generated by `datatypes()`
***********/

/***********
[info][section start] Section automatically generated by `noc_init()` in 'noc.py'
***********/
router[] noc = [
router {
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [NO_CONNECT, NO_CONNECT, 1, 2],
    priority_list: [NORTH, EAST, SOUTH, WEST, LOCAL],
    priority_list_temp: [0, 0, 0, 0, 0],
    serviced_index: 0,
    unserviced_index: 0,
    total_unserviced: 0,
    thisActivity: 0,
    lastActivity: 0,
    used: [false, false, false, false, false]
},
router {
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [NO_CONNECT, 0, NO_CONNECT, 3],
    priority_list: [NORTH, EAST, SOUTH, WEST, LOCAL],
    priority_list_temp: [0, 0, 0, 0, 0],
    serviced_index: 0,
    unserviced_index: 0,
    total_unserviced: 0,
    thisActivity: 0,
    lastActivity: 0,
    used: [false, false, false, false, false]
},
router {
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [0, NO_CONNECT, 3, NO_CONNECT],
    priority_list: [NORTH, EAST, SOUTH, WEST, LOCAL],
    priority_list_temp: [0, 0, 0, 0, 0],
    serviced_index: 0,
    unserviced_index: 0,
    total_unserviced: 0,
    thisActivity: 0,
    lastActivity: 0,
    used: [false, false, false, false, false]
},
router {
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [1, 2, NO_CONNECT, NO_CONNECT],
    priority_list: [NORTH, EAST, SOUTH, WEST, LOCAL],
    priority_list_temp: [0, 0, 0, 0, 0],
    serviced_index: 0,
    unserviced_index: 0,
    total_unserviced: 0,
    thisActivity: 0,
    lastActivity: 0,
    used: [false, false, false, false, false]
}];
/***********
[info][section end] Section automatically generated by `noc_init()`
***********/

/***********
[info][section start] Section automatically generated by `functions()` in 'noc.py'
***********/
// Calculate length of list
function int len(buffer option ls) = if ls == none then 0 else 1 + len(ls!.tl);

// Tell if the buffer is full
function bool isBufferFull(buffer option ls) = len(ls) >= BUFFER_LENGTH;

// Get the mirror direction
function int getDestinationChannel(int dir) =
    if dir == NORTH then SOUTH
    else if dir == WEST then EAST
    else if dir == EAST then WEST
    else if dir == SOUTH then NORTH
    else -1;

// Determine if the flits destination is in the same column as the current router
function int getColumnShift(int id, int dst) =
(dst % ((int)sqrt(NOC_MAX_ID + 1))) - (id % ((int)sqrt(NOC_MAX_ID + 1)));

// Return the front of the queue
function int peekFront(buffer option ls) =
    if ls == none then -1
    else if ls!.tl == none then ls!.hd
    else peekFront(ls!.tl);

// Add a flit to the buffer
function buffer option enqueue(int n, buffer option ls) =
    if len(ls) == BUFFER_LENGTH then ls
    else some(buffer {
        hd: n,
        tl: ls
    });

// Remove a flit from the buffer
function buffer option dequeue(buffer option ls) =
    if ls == none then none
    else if ls!.tl == none then none
    else some(buffer {
        hd: ls!.hd,
        tl: dequeue(ls!.tl)
    });

// Returns True if the buffer `ls` contains `id`, otherwise returns false 
function bool contains(int id, buffer option ls) =
	if ls == none then false 
	else contains(id, ls!.tl);
/***********
[info][section end] Section automatically generated by `functions()`
***********/

// property clk_partition = clk;

// property neverGeneratesFlitsForSelf0 = Pmax(<>(contains(0, noc[0].channels[LOCAL].buffer)));
// property neverGeneratesFlitsForSelf0 = A[](!(contains(0, noc[0].channels[LOCAL].buffer)));
// property neverGeneratesFlitsForSelf1 = A[](!(contains(1, noc[1].channels[LOCAL].buffer)));
// property neverGeneratesFlitsForSelf2 = A[](!(contains(2, noc[2].channels[LOCAL].buffer)));
// property neverGeneratesFlitsForSelf3 = A[](!(contains(3, noc[3].channels[LOCAL].buffer)));

function bool implies(bool l, bool r) = (!l) || r;

property r0LocalEmpty = A[](implies(clk == 9, noc[0].channels[LOCAL].isEmpty));
property r1LocalEmpty = A[](implies(clk == 9, noc[1].channels[LOCAL].isEmpty));
property r2LocalEmpty = A[](implies(clk == 9, noc[2].channels[LOCAL].isEmpty));
property r3LocalEmpty = A[](implies(clk == 9, noc[3].channels[LOCAL].isEmpty));

property r0NorthEmpty = A[](implies(clk == 9, noc[0].channels[NORTH].isEmpty));
property r1NorthEmpty = A[](implies(clk == 9, noc[1].channels[NORTH].isEmpty));
property r2NorthEmpty = A[](implies(clk == 9, noc[2].channels[NORTH].isEmpty));
property r3NorthEmpty = A[](implies(clk == 9, noc[3].channels[NORTH].isEmpty));

property r0EastEmpty = A[](implies(clk == 9, noc[0].channels[EAST].isEmpty));
property r1EastEmpty = A[](implies(clk == 9, noc[1].channels[EAST].isEmpty));
property r2EastEmpty = A[](implies(clk == 9, noc[2].channels[EAST].isEmpty));
property r3EastEmpty = A[](implies(clk == 9, noc[3].channels[EAST].isEmpty));

property r0SouthEmpty = A[](implies(clk == 9, noc[0].channels[SOUTH].isEmpty));
property r1SouthEmpty = A[](implies(clk == 9, noc[1].channels[SOUTH].isEmpty));
property r2SouthEmpty = A[](implies(clk == 9, noc[2].channels[SOUTH].isEmpty));
property r3SouthEmpty = A[](implies(clk == 9, noc[3].channels[SOUTH].isEmpty));

property r0WestEmpty = A[](implies(clk == 9, noc[0].channels[WEST].isEmpty));
property r1WestEmpty = A[](implies(clk == 9, noc[1].channels[WEST].isEmpty));
property r2WestEmpty = A[](implies(clk == 9, noc[2].channels[WEST].isEmpty));
property r3WestEmpty = A[](implies(clk == 9, noc[3].channels[WEST].isEmpty));

property r0IsReset = A[](implies(clk == 9, noc[0] == router {
    channels: [
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false},
        channel {buffer: none, serviced: false, isEmpty: true, isFull: false}],
    ids: [1, 2, NO_CONNECT, NO_CONNECT],
    // priority_list: [NORTH, EAST, SOUTH, WEST, LOCAL],
    priority_list_temp: [0, 0, 0, 0, 0],
    serviced_index: 0,
    unserviced_index: 0,
    total_unserviced: 0,
    thisActivity: 0,
    lastActivity: 0,
    used: [false, false, false, false, false]
}));

/***********
[info][section start] Section automatically generated by `processes()` in 'noc.py'
***********/
action generateFlits;
process GenerateFlits(int id) {
    int(0..NOC_MAX_ID) destination;

    if (clk < INJECTION_RATE_NUMERATOR) {
        // Add the new flit to the local buffer
        // If the destination is greater than or equal to the ID, we shift it
        // up by one to exclude the possiblity of sending a flit to ourselves
        generateFlits {=
            0: destination = DiscreteUniform(0, NOC_MAX_ID - 1),
            1: noc[id].channels[LOCAL].buffer = 
                enqueue(destination >= id ? 
                            destination + 1 : 
                            destination, noc[id].channels[LOCAL].buffer)
        =}
    }
    else {
        generateFlits // replaced tau to remove silly tau actions
    }
}

action prepRouter;
process PrepRouter(int id){
    // Prep all the channels
    prepRouter {=
        // North Channel (0)
        noc[id].channels[NORTH].isEmpty = len(noc[id].channels[NORTH].buffer) == 0,
        noc[id].channels[NORTH].isFull = isBufferFull(noc[id].channels[NORTH].buffer),

        // WEST Channel (1)
        noc[id].channels[WEST].isEmpty = len(noc[id].channels[WEST].buffer) == 0,
        noc[id].channels[WEST].isFull = isBufferFull(noc[id].channels[WEST].buffer),

        // East Channel (2)
        noc[id].channels[EAST].isEmpty = len(noc[id].channels[EAST].buffer) == 0,
        noc[id].channels[EAST].isFull = isBufferFull(noc[id].channels[EAST].buffer),

        // South Channel (3)
        noc[id].channels[SOUTH].isEmpty = len(noc[id].channels[SOUTH].buffer) == 0,
        noc[id].channels[SOUTH].isFull = isBufferFull(noc[id].channels[SOUTH].buffer),

        // Local Channel (4)
        noc[id].channels[LOCAL].isEmpty = len(noc[id].channels[LOCAL].buffer) == 0,
        noc[id].channels[LOCAL].isFull = isBufferFull(noc[id].channels[LOCAL].buffer)
    =}
}

// Send flit to northern router. src and dst are channels (ie NORTH, WEST, EAST, SOUTH, LOCAL), NOT the actual router ids!
process Send(int id, int ch, int dir) {
    advanceChannel;

    // If the destination is not full, and the channel has not been used in this cycle, then service the buffer
    if(!noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].isFull && !noc[id].used[dir]){
        advanceChannelSend {=
            // First, add flit to destination buffer
            1: noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].buffer =
                enqueue(peekFront(noc[id].channels[ch].buffer), noc[noc[id].ids[dir]].channels[getDestinationChannel(dir)].buffer),

            // Then, remove it from the source buffer
            2: noc[id].channels[ch].buffer = dequeue(noc[id].channels[ch].buffer),

            // Mark that output as used and that channel as serviced
            4: noc[id].used[dir] = true,
            4: noc[id].channels[ch].serviced = true,

            // Incrament the count for buffers serviced in this cycle
            4: noc[id].thisActivity++
        =}
    }
    // Otherwise, increment total unserviced buffers
    else{
        advanceChannelSend {=
            noc[id].total_unserviced++
        =}
    }
}

// Advance flits to respective buffers
process AdvanceFlits(int id, int ch){
    // If flit needs to stay on this row
    if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) == 0){
        // Send it north
        if(peekFront(noc[id].channels[ch].buffer) < id){
            Send(id, ch, NORTH)
        }
        // Or send it south
        else{
            Send(id, ch, SOUTH)
        }
    }
    // Else, if flit needs to go west
    else if(getColumnShift(id, peekFront(noc[id].channels[ch].buffer)) < 0){
        Send(id, ch, WEST)
    }
    // Else, flit needs to go east
    else{
        Send(id, ch, EAST)
    }
}

// Update a specific channel
action advanceChannel;
action advanceChannelSend;
process AdvanceChannel(int id, int ch){
    // If this channel was not assigned a neighbor or if it is
    // empty, then mark it as serviced and move on to the next one
    if ((ch != 4 && noc[id].ids[ch] == NO_CONNECT) || noc[id].channels[ch].isEmpty == true) {
        advanceChannel {=
            // Mark the channel as serviced
            noc[id].channels[ch].serviced = true
        =};
	    advanceChannelSend
    }
    // If the flit has reached its destination...
    else if (peekFront(noc[id].channels[ch].buffer) == id) {
        advanceChannel {=
            /* -- if the locan channel has not been used this clock cycle -- */
            // Mark the channel as serviced and used
            noc[id].channels[ch].serviced = !noc[id].used[LOCAL],
            noc[id].used[LOCAL] = !noc[id].used[LOCAL],

            // Incrament the count for buffers serviced in this cycle
            noc[id].thisActivity = !noc[id].used[LOCAL] ? noc[id].thisActivity + 1 : noc[id].thisActivity,

            // Remove this flit. It has reached its destination
            noc[id].channels[ch].buffer = !noc[id].used[LOCAL] ? dequeue(noc[id].channels[ch].buffer) : noc[id].channels[ch].buffer,

            /* -- if the locan channel has been used this clock cycle -- */
            // Otherwise, increment total unserviced buffers
            noc[id].total_unserviced = !noc[id].used[LOCAL] ? noc[id].total_unserviced : noc[id].total_unserviced + 1
        =};
	    advanceChannelSend
    }
    // Otherwise, the flit must be for another router
    else {
        AdvanceFlits(id, ch)
    }
}

// Update the directions of the next flits in the buffers
process AdvanceRouter(int id){
    AdvanceChannel(id, noc[id].priority_list[0]);
    AdvanceChannel(id, noc[id].priority_list[1]);
    AdvanceChannel(id, noc[id].priority_list[2]);
    AdvanceChannel(id, noc[id].priority_list[3]);
    AdvanceChannel(id, noc[id].priority_list[4])
}

process UpdatePriorityList(int id, int i){
    if (noc[id].channels[noc[id].priority_list[i]].serviced) {
        updatePriority {=
            0: noc[id].priority_list_temp[noc[id].total_unserviced + noc[id].serviced_index] = noc[id].priority_list[i],
            1: noc[id].serviced_index++
        =}
    }
    else {
        updatePriority {=
            0: noc[id].priority_list_temp[noc[id].unserviced_index] = noc[id].priority_list[i],
            1: noc[id].unserviced_index++
        =}
    }
}

// Update priority list
action updatePriority;
process UpdatePiority(int id) {
    // Reset all of the temp values
    updatePriority {=
        noc[id].priority_list_temp = [0, 0, 0, 0, 0],
        noc[id].serviced_index = 0,
        noc[id].unserviced_index = 0
    =};

    // Update the ordering of priorities in the lists
    UpdatePriorityList(id, 0);
    UpdatePriorityList(id, 1);
    UpdatePriorityList(id, 2);
    UpdatePriorityList(id, 3);
    UpdatePriorityList(id, 4);

    updatePriority {=
        // Make our next priority list the current priority list
        // However, if all of our channels are empty, then just reset
        // the priority list. This helps with the state space
        0: noc[id].priority_list = (noc[id].channels[0].isEmpty &&
                                    noc[id].channels[1].isEmpty &&
                                    noc[id].channels[2].isEmpty &&
                                    noc[id].channels[3].isEmpty &&
                                    noc[id].channels[4].isEmpty) ?
                                    [NORTH, EAST, SOUTH, WEST, LOCAL] : noc[id].priority_list_temp,

        // Reset the used and serviced variables
        1: noc[id].channels[0].serviced = false,
        1: noc[id].channels[1].serviced = false,
        1: noc[id].channels[2].serviced = false,
        1: noc[id].channels[3].serviced = false,
        1: noc[id].channels[4].serviced = false,
        1: noc[id].total_unserviced = 0,
        1: noc[id].used = [false, false, false, false, false],
        1: noc[id].priority_list_temp = [0, 0, 0, 0, 0],
        1: noc[id].serviced_index = 0,
        1: noc[id].unserviced_index = 0
    =}
}

// Update the noise tracking variables for all routers
process UpdateGlobalNoiseTracking(int id) {
    {= 
       // Update inductive noise
       0: inductiveNoise += abs(noc[id].lastActivity - noc[id].thisActivity) >= ACTIVITY_THRESH ? 1 : 0,
       
       // Update resistive noise
       0: resistiveNoise += noc[id].thisActivity >= ACTIVITY_THRESH ? 1 : 0,
       
       // Update trackers for next round
       1: noc[id].lastActivity = noc[id].thisActivity,
       2: noc[id].thisActivity = 0
    =}
}

// Router model
process Router(int id) {
    // Generate new flits
    GenerateFlits(id);
    // Determine what channels will send this cycle
    PrepRouter(id);

    // Send the flits
    AdvanceRouter(id);
    // Update the priority list
    UpdatePiority(id);
    // Update resistive and inductive values
    // UpdateGlobalNoiseTracking(id);

    // Sync w/ the clock -
    nextClockCycle;

    if (clk >= CLK_MAX) {
        stop
    } else {
        // recursive call for next clock cycle
        Router(id)
    }
}

// For syncing parallel processes
action nextClockCycle;
const int CLK_MAX = 0;
process Clock() {
    nextClockCycle {= clk = (clk + 1) % INJECTION_RATE_DENOMINATOR, clk_indicator = 1 =};
    if (clk >= CLK_MAX) {
        stop
    } else {
        Clock()
    }
}
/***********
[info][section end] Section automatically generated by `processes()`
***********/

/***********
[info][section start] Section automatically generated by `composition()` in 'noc.py'
***********/
par {
    :: Clock()
    :: Router(0)
    :: Router(1)
    :: Router(2)
    :: Router(3)
}
/***********
[info][section end] Section automatically generated by `composition()`
***********/

